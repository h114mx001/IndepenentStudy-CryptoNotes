{"title":"Hash functions","markdown":{"headingText":"Hash functions","headingAttr":{"id":"sec-Hash","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\nThis chapter will give you an introduction to Hash functions, where and why apply them, and also a fun vulnerability: Hash Length Extension. \n\n## Hash function\n\nIn general, you can think the hash function as taking an arbitrary long data, and then 'compress' it into a much smaller (and fixed size) string. It appears in many data structures, string recognition and many others in computer science.\n\nWith **Cryptographic Hash Function**, the function should be one-way: impossible to invert. Comparing with public key cryptography, this is a little bit different, as PKC processes could be invertible if some secrets is known. \nHere is an example of SHA1:\n\n![](/images/SHA1.png)\n\nCryptographic hash functions are used to validate messages, generate digital signatures, and store passwords securely in databases. \n\nHash functions are particularly helpful in asymmetric cryptography for compressing arbitrary length communications to a value with a smaller bit-length than the modulus when signing messages using RSA or protocols such as (EC)DSA or Elgamal. \n\nNormally, the cryptographic hash functions must be resistant to this three forms of attacks:\n\n+ Pre-image attack: Given $x = hash(m)$, it must be practically impossible to find $hash(m_0) = x$. (This can be interpreted as one-way function).\n\n+ Second pre-image attack: given $m_1, hash(m_1)$, it must be impossible find $m_2$ that $hash(m_1) = hash(m_2)$.\n\n+ Collision: It must be practically impossible to find any pair of messages $m_1, m_2$ that $hash(m_1) = hash(m_2)$. The main difference of collision and second pre-image is that, collision do not require a known $m_1$, but searching for a pair. \n\nOne remarkable think is: if a pre-image attack is known, then, it could lead to consequences as second pre-image attack and collision; but having a collision is not necessarily lead to other attacks. \n\nIn Python, `hashlib` works pretty well as a hash generator.\n\n```Python\nimport hashlib\nh = hashlib.new('sha256')\nh.update(b\"Nobody inspects the spammish repetition\")\nh.hexdigest()\n```\n\n```{sagemath}\nimport hashlib\nh = hashlib.new('sha256')\nh.update(b\"Nobody inspects the spammish repetition\")\nh.hexdigest()\n```\n\nYou can look more deeply in the [`hashlib` documentation](https://docs.python.org/3/library/hashlib.html).\n\n## Merkle–Damgård construction\n\nMerkle–Damgård construction is a proven way to build a good hash function. \n\n![](/images/MD.png)\n\nWe can talk pretty much about this Construction, but I will write here several key points in it:\n\n+ It is proven that, if the block $f$ is cryptographically secured, then the whole MD construction is secured. \n\n+ The padding is a must-have in cryptographic hash function. And it also needs to be done in a good way. \n\nFor example, if we pad the message with only `\\x00` if it does not fit the block of MD construction, then this two message:\n\n```\nm1 = 'aaaaaaaaaaa'\naaa|aaa|aaa|aa0|\n              |padding\nm2 = 'aaaaaaaaaaa0'\naaa|aaa|aaa|aa0|\n```\n\nwill have the same hash results. Normally, regardless of the size of message fits the required length for each block or not, the hash function will always pad it with some values. \n\n+ **Sad news** many algorithm built on Merkle–Damgård is not cryptographically safe anymore, one big example is MD5. \n\nComputing the hash value of this two value raises the same hash:\n\n```Python\na = 0xd131dd02c5e6eec4693d9a0698aff95c2fcab58712467eab4004583eb8fb7f8955ad340609f4b30283e488832571415a085125e8f7cdc99fd91dbdf280373c5bd8823e3156348f5bae6dacd436c919c6dd53e2b487da03fd02396306d248cda0e99f33420f577ee8ce54b67080a80d1ec69821bcb6a8839396f9652b6ff72a70\na_faker = 0xd131dd02c5e6eec4693d9a0698aff95c2fcab50712467eab4004583eb8fb7f8955ad340609f4b30283e4888325f1415a085125e8f7cdc99fd91dbd7280373c5bd8823e3156348f5bae6dacd436c919c6dd53e23487da03fd02396306d248cda0e99f33420f577ee8ce54b67080280d1ec69821bcb6a8839396f965ab6ff72a70\nimport hashlib\nhashMachine = MD5.new(a)\nprint(hashMachine.hexdigest())\nhashMachine = MD5.new(a_faker)\nprint(hashMachine.hexdigest())\n```\n\n```{sagemath}\na = \"4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa200a8284bf36e8e4b55b35f427593d849676da0d1555d8360fb5f07fea2\"\na_faker = \"4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa200a8284bf36e8e4b55b35f427593d849676da0d1555d8360fb5f07fea2\"\nfrom Crypto.Hash import MD5\nhashMachine = MD5.new(bytes.fromhex(a))\nprint(hashMachine.hexdigest())\nhashMachine = MD5.new(bytes.fromhex(a_faker))\nprint(hashMachine.hexdigest())\n```\n\nA very cool properties that hashes based on Merkle–Damgård construction is that, if a collision is found, if we append same bytes into the collision, it will continue to become a collision (You may can explain it by looking at MD construction).\n\n## Hash length extension\n\nWith Merkle-Damgard construction-based hash, a very cool attack called `Hash length extension`. \n\nLooking back into the MD construction, the hash resulted after a process is the hashes of the message $m$ and its padding $p$, let's name it $m || p$. \n\nIf an adversary have the $hash(m || p)$, and knowing length of $m$, he could compute a valid hash of $m || p || z$, with $z$ is his invalid data. \n\nWhen the hash function needs to find $hash(m || p || z)$, with $m || p$ fits the block size ($len(m || p) = kn$), the next state will have IV as $hash(m || p)$!. For knowing this IV states, we can compute the continuous block. If attacker needs to forge a hash of $m || p || z || p'$, for $p'$ is the padding for $z$, he would use IV as $hash(m || p)$. \n\nAn example on [Wikipedia](https://en.wikipedia.org/wiki/Length_extension_attack):\n\n```\nOriginal Data: count=10&lat=37.351&user_id=1&long=-119.827&waffle=eggo\nOriginal Signature: 6d5f807e23db210bc254a28be2d6759a0f5f5d99\n```\nIf the hacker needs to craft this message:\n```\nDesired New Data: count=10&lat=37.351&user_id=1&long=-119.827&waffle=eggo&waffle=liege\n```\n\nAs we have known the signature of previous data, we can compute the hash value of the desired data, with IV = hash of original.\n\nIt would be finding hash of something like this:\n\n```\nNew Data: count=10&lat=37.351&user_id=1&long=-119.827&waffle=eggo\\x80\\x00\\x00\n          \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\n          \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\n          \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\n          \\x00\\x00\\x00\\x02\\x28&waffle=liege\n```\n\nYou can try to make a hash length extension :D.\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":false,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"HashFunctions.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.280","bibliography":["references.bib"],"jupyter":{"kernelspec":{"name":"sagemath","language":"sagemath","display_name":"SageMath 9.6"}},"editor":{"render-on-save":true},"theme":"zephyr"},"extensions":{"book":{"multiFile":true}}},"pdf":{"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":false,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"HashFunctions.pdf"},"language":{},"metadata":{"block-headings":true,"bibliography":["references.bib"],"jupyter":{"kernelspec":{"name":"sagemath","language":"sagemath","display_name":"SageMath 9.6"}},"editor":{"render-on-save":true},"documentclass":"scrreprt"},"extensions":{"book":{}}}}}