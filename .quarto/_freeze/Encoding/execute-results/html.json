{
  "hash": "dfcb1bb89f032401b5bbe8978447a220",
  "result": {
    "markdown": "# Encoding {#sec-Foundations}\n\n## Introductions \n\nAs a two-year (or more) CTF players, I have not see any challenges that works too much on the encoding (As they are standardized). Some may appear in challenges of Web or Pwn, where the format of the data matters. In this section, I will introduce several common types of encoding for you!\n\n## ASCII\n\nASCII is 7-bit encoding standard, where each letter is assigned with a number from 0-127. Besides this ASCII table, we also have an extended ASCII, where 256 characters are encoded. You can have a look at [ASCII Table](https://www.asciitable.com/) to see it clearer. \n\n```Python\ns = \"Hello World\"\nprint([ord(c) for c in s])\n```\n\n::: {.cell execution_count=1}\n\n::: {.cell-output .cell-output-stdout}\n```\n[72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]\n```\n:::\n:::\n\n\n## Hex \n\nHex stands for Hexadecimal, i.e. base 16. Basically, you can understand Hex as a version of ASCII but in hexadecimal rather than decimal. \n\n```Python\ns = \"Hello World\"\nprint([hex(ord(c)) for c in s])\nprint(bytes(s, encoding='utf-8').hex())\n```\n\n::: {.cell execution_count=2}\n\n::: {.cell-output .cell-output-stdout}\n```\n['0x48', '0x65', '0x6c', '0x6c', '0x6f', '0x20', '0x57', '0x6f', '0x72', '0x6c', '0x64']\n48656c6c6f20576f726c64\n```\n:::\n:::\n\n\n## Base64\n\nUsing Base64 encoding, you can represent binary data as ASCII string, with an alphabet of 64 characters. Some other versions of Base64, like Base58 (Using in Bitcoin, remove some 'look-the-same' character like l (normalcase l) and I (uppercase i)) are alse used widely. \n\nIn Python, you can use the library `base64` for working with this encoding.\n\n```Python\ns = \"Hello World\"\nimport base64\nb64enc = base64.b64encode(s)\nprint(b64enc)\nprint(base64.b64decode(b64enc))\n```\n\n::: {.cell execution_count=3}\n\n::: {.cell-output .cell-output-stdout}\n```\nb'SGVsbG8gV29ybGQ='\nb'Hello World'\n```\n:::\n:::\n\n\n## Bignum and Bytes\n\nIf you want to encrypt a word (\"HELLO\", for example); most of the case, you can't apply encryption directly on it. A solution is that: concatenate the hex value of each characters. For example:\n\n```\nmessage: HELLO\nascii bytes: [72, 69, 76, 76, 79]\nhex bytes: [0x48, 0x45, 0x4c, 0x4c, 0x4f]\nbase-16: 0x48454c4c4f\nbase-10: 310400273487 \n```\n\nWhen working with these bignums, a Python library [PyCryptodome](https://pypi.org/project/pycryptodome/) provides two functions to convert back and forth: \n\n\n```Python\ns = b\"Hello World\"\nprint(s.hex())\nfrom Crypto.Util.number import long_to_bytes, bytes_to_long\n# The usage of command\nprint(bytes_to_long(s))\n\n# Compare with the hex value\nprint(hex(bytes_to_long(s)))\n\n# Decoding\nprint(long_to_bytes(bytes_to_long(s)))\n```\n\n::: {.cell execution_count=4}\n\n::: {.cell-output .cell-output-stdout}\n```\n48656c6c6f20576f726c64\n87521618088882533792115812\n0x48656c6c6f20576f726c64\nb'Hello World'\n```\n:::\n:::\n\n\nAlso, there are some forms of encoding like **URL Encoding**, which uses a lot in our hyperlinks. You can always search them, when you need it xD.\n\n",
    "supporting": [
      "Encoding_files"
    ],
    "filters": [],
    "includes": {}
  }
}