{
  "hash": "cc251f40c57553bef27677461b547e29",
  "result": {
    "markdown": "# ECDLP Attacks \n\nIn the last chapter of PKC, we will revisit the Pohlig-Hellman Algorithm, but in the theme of Elliptic Curve. \n\n## Pohlig-Hellman in ECC \n\nIn elliptic curve, we know that we need to choose a finite field $\\mathbb{F}_p$. If this prime $p$ is smooth, we can sure that the discrete logarithm on the curve is also vulnerable. As in Pohlig-Hellman chapter for Diffie-Hellman, the discrete logarithm on the curve could be computed on each curve with the finite field of prime factorization. \n\nAlso, SageMath comes with the function `discrete_log()` for computing this one:\n\n```Python\ndef discreteLogarithm(p, a, b, G, B, A):\n    '''\n        Discrete Logarithm for a curve that its parameter is smooth. \n        p: prime number \n        a, b: parameters of the curve\n        G: generator point\n        B: Bob's public key\n        A: Alice's public key\n    '''\n    E = EllipticCurve(GF(p), [a, b])\n    G = E(G)\n    B = E(B)\n    A = E(A)\n    b = G.discrete_log(B)\n    sharedSecret = (A*b).xy()[0]\n    return sharedSecret\n\np = 310717010502520989590157367261876774703\na = 2 \nb = 3\nG = [179210853392303317793440285562762725654, 105268671499942631758568591033409611165]\nB = [272640099140026426377756188075937988094, 51062462309521034358726608268084433317]\nA = [280810182131414898730378982766101210916, 291506490768054478159835604632710368904]\nprint(discreteLogarithm(p, a, b, G, B, A))\n```\n\n::: {.cell execution_count=1}\n\n::: {.cell-output .cell-output-stdout}\n```\n171172176587165701252669133307091694084\n```\n:::\n:::\n\n\n## Group isomorphism for ECDLP attack\n\nLet's first recall about group isomorphism. \n\nWith two group $(G, \\cdot)$ and $(H, \\odot)$, a group isomorphism $\\phi: G \\leftarrow H$ is a bijective mapping such that the group operation is preserved; that is:\n\n$$\n\\phi(a \\cdot b) = \\phi(a) \\odot \\phi(b)\n$$\n\nfor all $a, b \\in G$. The left-hand side operation exists in $G$, while the right-hand side operation exists in $H$. \n\nGroup isomorphism is a very powerful tool to solve ECDLP (and any other cryptography based on algebraic group). The key idea is that we can find a mapping $\\phi$ from the harder group $G$ to an easier group $H$, then solve the discrete logarithm here. With the context of elliptic curve cryptography, we often want to transfer the curve back to the modulo operation, as the elliptic curve often use smaller primes compared to RSA, and sometimes the prime itself is smooth too, which helps us a lot in solving the DLP in here. \n\nLet's have an example! Suppose we want to attack the ECDLP on the curve $Y^2 = X^3 + Ax + B$ under the $\\mathbb{F}_p$ where a, b, p, generator $G$ is: \n\n```Python\np = 0xa15c4fb663a578d8b2496d3151a946119ee42695e18e13e90600192b1d0abdbb6f787f90c8d102ff88e284dd4526f5f6b6c980bf88f1d0490714b67e8a2a2b77\na = 0x5e009506fcc7eff573bc960d88638fe25e76a9b6c7caeea072a27dcd1fa46abb15b7b6210cf90caba982893ee2779669bac06e267013486b22ff3e24abae2d42\nb = 0x2ce7d1ca4493b0977f088f6d30d9241f8048fdea112cc385b793bce953998caae680864a7d3aa437ea3ffd1441ca3fb352b0b710bb3f053e980e503be9a7fece\nE = EllipticCurve(GF(p), [a, b]) # Define the curve \nG = E(0x39f15e024d44228fd11c58a71c312fd64167c7d249d5677da0dfb4b9c3ed0f90701837a5e77b5a2b74433d7fbe027cd0c73b5aa7b300f7384521af0dc283dc6d,\n      0x5f3636a89167a6fbb7b7d1ad97d11c70756835b5f1273e20c06d9e022d74648ec22a3f92c378196d137c3f2027a67381be79e1c0d65cd9b61211a77a3842c8b2)\n```\n\n\n\nSuppose that we have collected Alice's public key in ECDH key exchange is:\n\n```Python\nA = E(0x5aa8b5cf3124c552881ba67c14c863bb2ff30d960fe41b61123d2025cdddf0ea75e92d76326be9fb09b9a32373fc278ac8d5cf5ca83b9e517ce347c6879bef51,\n      0x2e3ddec1b35930b1039351b2814252186b30ce27ce15eda4351428868ae8593ab8c61c034ba10041cce205d7f7102c292f30ac5f3d2a2c2f3a463d837df070cd)\n```\n\n\n\nThat means, we need to find a number $k$ such that $A = kG$ under the curve $E(\\mathbb{F}_p)$. You can first, try implement the solution by `discrete_log()` function in SageMath. But I am pretty sure you will fail `:)`. \n\nLet's try something differently. \n\n### Anomalous curve \n\nIf you notice a little bit, you may find out that the order of this curve is exactly the same with the prime $p$!. \n\n```Python\nq = E.cardinality()\nassert(p == q)\nprint(p == q)\n```\n\n::: {.cell execution_count=4}\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n```\n:::\n:::\n\n\nThis hints us that we can find a group isomorphism from curve to the $\\mathbb{Z}_p$. Now, let me introduce a little new concept. \n\nThis method attempts to provide a group isomorphism $\\phi: E \\rightarrow \\mathbb{F}_p$, via a concept of **Augmented Point Addition**\n\nWe will assign a point $P \\in E$ with a value $\\alpha \\in \\mathbb{F}_p$: $[P, \\alpha]$. We introduce the augment addition as: \n$$\n[P, \\alpha] + [Q, \\beta] = [P + Q, \\alpha + \\beta + f(P, Q)]\n$$\nWhere $P + Q$ is normal elliptic curve addition; and $f(P, Q)$ return the slope of line $PQ$ if $P \\neq Q$ and the tangent if $P = P$. The function returns 0 for any other cases.\n\n### Transfering to normal (weak) DLP\n\nWe can define a function $\\phi(P)$ as finding a number $p$ such: \n\n$$\np[P, 0] = [\\mathcal{O}, \\alpha]\n$$\n\nIt turns out we always can find this value $p$ for every point $P$. We can define the subgroup generated by $P$ in the curve $E$ as all points satisfied $nP \\in E$. In here, $p$ will be equal to the order of the subgroup, as it is closed under the group addition. Even more interesting, we can also prove that the augmented point addition is an homomorphism. \n\nBack to our original problem. We are given Alice public key $A = kG$ where $k$ is private key and $G$ is the generator of the curve. We need to solve this ECDLP. \n\nAssumming $\\alpha = \\phi(A), \\gamma = \\phi(G)$\nWe know that $\\phi$ is a group isomorphism. Then, it must follow:\n\n$$\n\\alpha = \\phi(A) = \\phi(kG) = k\\phi(G) = k \\gamma\n$$\n\nAs $\\alpha = k\\gamma$, we can find:\n$$\nk = \\alpha \\gamma^{-1}\n$$\n\nCan you implement the algorithm? Let's have a check! If you do thing correctly, the result of $k$ should be `2200911270816846838022388357422161552282496835763864725672800875786994850585872907705630132325051034876291845289429009837283760741160188885749171857285407`.\n\n```Python\ndef f(P, Q): \n    if P[2] == 0 or Q[2] == 0 or P == -Q: \n        return 0 \n    if P == Q: \n        a = P.curve().a4() \n        return (3*P[0]^2+a)/(2*P[1]) \n    return (P[1]-Q[1])/(P[0]-Q[0]) \n\ndef add_augmented(PP, QQ):\n    (P, u), (Q, v) = PP, QQ\n    return [P+Q, u + v + f(P,Q)]\n\ndef scalar_mult(n, PP):\n    t = n.nbits()\n    TT = PP.copy()\n    for i in range(1,t):\n        bit = (n >> (t-i-1)) & 1\n        TT = add_augmented(TT, TT)\n        if bit == 1:\n            TT = add_augmented(TT, PP)\n    return TT\n\ndef solve_ecdlp(P,Q,p):\n    R1, alpha = scalar_mult(p, [P,0])\n    R2, beta  = scalar_mult(p, [Q,0])\n    return ZZ(beta*alpha^(-1))\n```\n\n::: {.callout-tip}\nFinding an isomorphism can help you a lot :D. In CTF competition, you may research them on scientific journal. With right keywords, you can have the isomorphism in your hand! \n:::\n\n",
    "supporting": [
      "ECC_Attacks_files"
    ],
    "filters": [],
    "includes": {}
  }
}