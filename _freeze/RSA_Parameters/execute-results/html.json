{
  "hash": "1329af154cb75847cf09966942a2349d",
  "result": {
    "markdown": "# Bad choices of parameters & Side-channel {#sec-Asymmetric}\n\nThe bad choice of parameters in RSA can come in many variants: low public, low private, etc. and also in the implementations of the RSA and also the prime generator. \n\n\n## Common modulus \n\nIf lucky enough, we capture two messages with two semiprimes $n_1$ and $n_2$ that share a same prime factor, indeed we can find the prime factorization of both, via finding $GCD(n_1, n_2)$. \n\nAlthough this attack seems impractical, a [research paper](https://eprint.iacr.org/2012/064.pdf) has found out that about 3-5% of public key on the Internet (that they can find out), share the prime factorization. With the method of rainbow attack which has been introduced in the previous chapter, many more could be broken. \n\n## Low public exponent \n\nA popular choice of $e$ is $3$, as it will reduce the time to encrypt. However, with a big choice of public exponent, this may make the ciphertext in danger, as $3$ times of exponent may do not change the value under the modulo. The root can be computed quickly, via the library `gmpy2` of Python. \n\n```Python\nfrom gmpy2 import iroot\nfrom Crypto.Util.number import *\np, q = getPrime(512), getPrime(512)\nn = p*q \nphiN = (p - 1)*(q - 1)\ne = 3\nd = inverse(e, n)\nm = getRandomNBitInteger(256)\nc = pow(m, e, n)\nm_break = iroot(int(c), int(e))\nprint(m_break)\nassert m_break[0] == m \nprint(m)\n```\n\n::: {.cell execution_count=1}\n\n::: {.cell-output .cell-output-stdout}\n```\n(mpz(85466728970802496052231641309227590688461946610431708918707661868612928527412), True)\n85466728970802496052231641309227590688461946610431708918707661868612928527412\n```\n:::\n:::\n\n\n## Low private exponent \n\nIn another way, a small choice of private exponent (can be created by a too huge public exponent), also can leak the ciphertext. In here, we will look at the **Wiener's attack.**\n\nAs we know, the $ed \\equiv 1 \\pmod{\\phi(n)}$, in another words, $ed - k\\phi(n) = 1$. Divide both side with $d\\phi(n)$:\n\n$$\n\\bigg | \\frac{e}{\\phi(n)} - \\frac{k}{d} \\bigg | = \\frac{1}{d\\phi(n)}\n$$\n\nWith a huge $d\\phi(n)$, we will have a negligible $\\frac{1}{d\\phi(n)}$. Therefore, $\\frac{e}{\\phi(n)}$ could be used as an approximation of $\\frac{k}{d}$, or vice versa. Although we know $e$, we don't know $\\phi(n)$. \n\nHowever, there is a theorem, from M. Wiener, that can help us a little bit: \n\n::: {.callout-tip}\n## Wiener's theorem\n\nLet $n = pq$ $(q \\lt p \\lt 2q)$, If the private exponent $d < \\frac{1}{3}N^{1/4}$, then an advisery can recover $d$.\n\n:::\n\nThe proof can be found in [Wikipedia](https://en.wikipedia.org/wiki/Wiener%27s_attack) page of Wiener's theorem.\n\nThe core of the algorithm is that, we can use $n$ as $\\phi(n)$ in the context of Wiener's attack. Then, as we has stated $\\frac{e}{\\phi(n)}$ could be used as an approximation of $\\frac{k}{d}$, then either $\\frac{e}{n}$ (in the context of this attack). We use a method of `Continued Fraction` on $\\frac{e}{n}$, then consequently find **convergents** of its and check if we can find the right $\\frac{k}{d}$. Once we know this, we could find back $d$ via an quadratic equation. Consequently, we could find back the factorization of $n$.   \n\n\n```Python\ndef wiener(n, e, c):\n    '''\n    Solve for d in c = m^e mod n using the Wiener attack.\n    '''\n    # Calculate continued fraction expansion of e/n\n    frac = continued_fraction(e / n)\n    convergents = [[x.numerator(), x.denominator()] for x in frac.convergents()]\n    # Iterate over convergents\n    for (k, d) in convergents:\n        # Check if d is actually an integer\n        if k == 0 or d%2 == 0 or e*d % k != 1:\n            continue\n        phi = (e*d - 1)/k\n        # Create the polynomial\n        x = PolynomialRing(RationalField(), 'x').gen()\n        f = x^2 - (n-phi+1)*x + n\n        roots = f.roots()\n        # Check if polynomial as two roots\n        if len(roots) != 2:\n            continue\n        # Check if roots of the polynomial are p and q\n        p,q = int(roots[0][0]), int(roots[1][0])\n        if p*q == n:\n            return d, k\n    # No solution found\n    return None\n\nn = 6727075990400738687345725133831068548505159909089226909308151105405617384093373931141833301653602476784414065504536979164089581789354173719785815972324079\ne = 4805054278857670490961232238450763248932257077920876363791536503861155274352289134505009741863918247921515546177391127175463544741368225721957798416107743\nc = 5928120944877154092488159606792758283490469364444892167942345801713373962617628757053412232636219967675256510422984948872954949616521392542703915478027634\nd, k = wiener(n, e, c)\nphiN = (e*d - 1) // k\nprint(phiN)\n# solve for the prime factorization \nx = var('x')\nf = n - n/x - x + 1 - phiN\np, q = [x[0] for x in f.roots()]\nassert p*q == n\nprint(f\"n = {p}*{q}\")\n```\n\n::: {.cell execution_count=2}\n\n::: {.cell-output .cell-output-stdout}\n```\n6727075990400738687345725133831068548505159909089226909308151105405617384093204788307013638609485547090121764648347578045648962637915516010740917782550840\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nn = 63949859459297920725542167940404754256294386312715512490347273751054137071981*105192975360365123391387526351896101933106732127903638948310435293844052701259\n```\n:::\n:::\n\n\n## Hastad's Broadcast Attack \n\nIf someone send same message over and over again, without any padding; someone could read the messages, from the Hastad's Broadcast Attack.\n\nAssume that the adversary collected $i$ ciphertexts ($i \\gt e$), then we can have a system of modular equation: \n\n$$\n\\left\\{\\begin{matrix}\nc_1 &\\equiv m^e \\pmod{n_1} \\\\\nc_2 &\\equiv m^e \\pmod{n_2} \\\\ \n...\\\\\nc_i &\\equiv m^e \\pmod{n_i} \n\\end{matrix}\\right.\n$$\n\nFrom Chinese Remainder Theorem, we could find a number $C \\equiv m^e \\pmod{\\Pi_{j=1}^i n_j}$. As the multiplication of $n_i$ is really big, we can sure that taking $e^{th}$-root of $m^e$ could help us get the ciphertext.\n\n```Python\n# Implementation of Hastad's Broadcast attack, normal version\ndef Hastad(ciphertext, n):\n    x = crt(ciphertext, n)\n    return real_nth_root(x, e)\n\nn1 = 15531155256715702473857617704486808708718149144340218293989572553\nn2 = 4665876664449238167503227140673941051177208287344383452644505383\nn3 = 21183715744016961916768204882841616031088804561756503460509763179\ne = 3\nm = 23333333333333333333333333333333333333333333\nc1 = 3545246357420027751080801513596354805792507454079198980994208613\nc2 = 2707010410568402623621857261477803260225040847370109587024036966\nc3 = 9988366267699268191504634643058847989157961583452909799090445547\n\nn = [n1, n2, n3]\nc = [c1, c2, c3]\nmessage = Hastad(c, n)\nassert pow(message, e, n1) == c1\nprint(message)\n```\n\n::: {.cell execution_count=3}\n\n::: {.cell-output .cell-output-stdout}\n```\n23333333333333333333333333333333333333333333\n```\n:::\n:::\n\n\nWith some more sophisticated padding (but fixed), the attack still can be applied via the Coppersmith's method. The clearer explaination could be found via Wikipedia page of this attack.\n\n## Side-channel attack example\n\nThe side-channel attack is a big class of attack, so in here we just have a look at a small mechanism of it: the square-and-multiply algorithm. Most of modular arithmetic implementation for exponentation is something like this:\n\n```Python\ndef exponent(a, b, n): \n    '''\n        Computing a^b mod n\n    '''\n    res = 1\n    while (b > 0):\n        if (b % 2 == 1):\n            res = ((res % n) * (a % n)) % n \n        a = ((res % n) * (res % n)) % n\n        b //= 2\n    return res \n```\n\nAs you may notice, if the current bit of $b$ in the above process is 1, it will execute the multiplication twice, rather than in case the bit is 0. With big number of RSA, this could require a noticeable amount of time. \n\nTherefore, if someone can attach the power clock on the decryption device; and looking for the pattern of 'decryption':\n\n![](/images/multiplySideChannel.png)\n\nThen, this could reveal the bit of $d$. \n\n## A very quick introduction to Coppersmith's method \n\nDon Coppersmith, a mathematician, has introduced a method of solving modular polynomials in polynomial time. Basically, his method will convert the modular polynomials under a modulo to a normal polynomial in $\\mathbb{Z}$, then we can apply the numerical analysis method on the new polynomial. This conversion is supported by an algorithm called [LLL lattice basis reduction](https://en.wikipedia.org/wiki/Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm)\n\nTo provide a quick example, we will examine if a RSA process using a fixed padding scheme. \n\nAssume we have two guys is sharing their AES-256 key. As they know RSA without padding is vulnerable, they used this padding scheme:\n\n$$\nm = 2^{1024} - 2^{128} + k\n$$\n\nFor $k$ is their key. $m$ is the padded-key. \n\nTherefore, the ciphertext will be sent can be written as:\n\n$$\nc \\equiv (2^{1024} - 2^{128} + k)^e \\pmod n \n$$\n\nThen, we could have a polynomial $f(x) = (2^{1024} - 2^{128} + k)^e - c = 0$ under the $\\mathbb{Z}_n$.\n\nWith the Coppersmith's method, we can solve this polynomial for $k$:\n\n```Python\nfrom Crypto.Util.number import *\n\ne = 3\np, q = getPrime(512), getPrime(512)\nn = p*q \nkey = getRandomNBitInteger(128)\n# print(key)\nm = 2**1024 - 2**128 + key\nc = pow(m, e, n)\nprint(c)\n\nK = Zmod(n)\nP.<x> = PolynomialRing(K, implementation = 'NTL')\nf = (2^1024 - 2^128 + x)^e - c \nkeyBroken = f.small_roots()[0]\nassert keyBroken == key\nprint(keyBroken)\n```\n\n::: {.cell execution_count=4}\n\n::: {.cell-output .cell-output-stdout}\n```\n82633033845796004747549573332791642419336976223134503191365351063499016327870528606411650067623106729110435236002973001108860823873209355855425694267378772683429911986067425672621927056108387620153618400631818657150449693722782685126044287318464943689078280311043761541667438647198552521827816508055402758969\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n286929976551044907179886525566763542034\n```\n:::\n:::\n\n\nThe Coppersmith's method is applied in a very wide range of attacks if there is a fixed relationship between the components of RSA. A very noticable case is the [ROCA attack](https://en.wikipedia.org/wiki/ROCA_vulnerability), that have leaked more than hundred thousands of ID cards in Estonian. \n\n## Conclusion \n\nRSA attacks is in a wide range, and different methods that this document can not cover it all. For a general knowledge of RSA, I recommend you to spend time on this paper of professor Dan Boneh:\n[Twenty years of Attacks on RSA Cryptosystem](http://crypto.cs.mcgill.ca/~crepeau/CS547/RSA-survey.pdf). Also, there are some compiled version of many RSA attacks on GitHub, like this one: \n[RsaCtfTool][(https://github.com/RsaCtfTool/RsaCtfTool).\n\n",
    "supporting": [
      "RSA_Parameters_files"
    ],
    "filters": [],
    "includes": {}
  }
}