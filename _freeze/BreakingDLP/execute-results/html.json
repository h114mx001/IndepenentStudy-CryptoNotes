{
  "hash": "894f23455d2ed74173df4f89b730a249",
  "result": {
    "markdown": "# Breaking DLP {#sec-Asymmetric}\n\nIn this chapter, we will cover the methods of breaking the Discrete Logarithm - the core of Diffie-Hellman. \n\nFor the uniform, in this chapter, we will try to solve the problem of Discrete Logarithm on $g^x \\equiv h \\pmod p$, with $p, g, h$ are given. \n\n## Baby step, giant step \n\nThis algorithm would be able to break the Discrete Logarithm in the complexity $O(\\sqrt{n})$, for $n$ is the bit-size of $x$. \n\nLet's give $x$ a bound, $0 \\lt x \\le 2^{40}$. \n\nLet $B = 2^{20}$. $x < B^2$, then we can write down $x$ as:\n\n$$\nx = x_0\\cdot B + x_1\n$$\n\nwhere $x_0, x_1 \\in [0, B-1]$\n\n$$\nh \\equiv g^x \\equiv g^{x_0B+x_1} \\equiv (g^B)^{x_0} \\cdot g^{x_1} \\pmod p \n$$\n\nThen, if we divide both side with $g^{x_1}$: \n\n$$\n\\frac{h}{g^{x_1}} \\equiv (g^B)^{x_0} \\pmod p$\n$$\n\nFrom here, we can find the logarithm by building the hash table of every value $\\frac{h}{g^x_1}$; then, finding if we have a collision of $(g^B)^{x_0}$ for both $x_0, x_1 \\in \\mathbb{Z}_p$\n\nIf we have found such a pair $x_0, x_1$, we can compute back $x = x_0B + x_1$.\n```Python\nfrom math import ceil, sqrt\n\n\ndef bsgs(g, h, p):\n    '''\n    Solve for x in h = g^x mod p given a prime p.\n    If p is not prime, you shouldn't use BSGS anyway.\n    '''\n    N = ceil(sqrt(p - 1))  # phi(p) is p-1 if p is prime\n    # Store hashmap of g^{1...m} (mod p). Baby step.\n    tbl = {pow(g, i, p): i for i in range(N)}\n    # Precompute via Fermat's Little Theorem\n    c = pow(g, N * (p - 2), p)\n    # Search for an equivalence in the table. Giant step.\n    for j in range(N):\n        y = (h * pow(c, j, p)) % p\n        if y in tbl:\n            return j * N + tbl[y]\n    # Solution not found\n    return None\n\nprint(bsgs(7894352216, 355407489, 604604729))\n```\n\n::: {.cell execution_count=1}\n\n::: {.cell-output .cell-output-stdout}\n```\n102900819\n```\n:::\n:::\n\n\n## Pohlig-Hellman Algorithm\n\n### Smooth number \n\nSmooth prime could be informally interpreted as having its order (i. e. $p-1$) to have many small primes in their factorization. More specifically, a number is $B$-smooth if it has its primes to be smaller or equal than $B$.\n\n+ For example, prime $101$ is $5$-smooth, as its order $100 = 2^2 \\cdot 5^5$ \n\n### Pohlig-Hellman\n\nRecall, in the discrete logarithm problem, $g^x \\equiv h \\pmod p$, $p$ is prime; which we cannot apply some algorithms like Chinese Remainder Theorem on $p$ directly. However, The solution of $x$ only live in $\\mathbb{Z}_{p-1}$ (Can be explained by Fermat's Little Theorem), which hints us about the using of factorization of $p-1$ may help in this case. \n\nThe Pohlig-Hellman Algorithm exploit this fact, and also with the support of Lagrange's Theorem. The process of the algorithm could be shortly written as: \n\n::: {.callout-note}\n## Pohlig-Hellman Algorithm \n\nAssume the prime $p$ has its order $N = q_1^{e_1} \\cdot q_2^{e_2} \\ldots q_t^{e_t}$\n\n+ **Step 1**: for each $1 \\le i \\le t$, let:\n$$\n\\displaylines{g_i \\equiv g^{N/q_i^{e_i}} \\qquad h_i \\equiv h^{N/q_i^{e_i}} \\pmod N}\n$$\n\nThen, according to the Lagrange's Theorem, $g_i$ has prime order $q_i^{e_i}$. Therefore, we can solve this problem:\n\n$$\ng_i^y \\equiv h_i \\pmod{q_i^{e_i}}\n$$\n\nUsing the \"Baby step, giant step\" is a choice. \n\n+ **Step 2**: Then, we can apply CRT on:\n\n$$\n\\left\\{\\begin{matrix}\nx &\\equiv y_1 \\pmod{q_1^{e_1}} \\\\\nx &\\equiv y_2 \\pmod{q_2^{e_2}} \\\\ \n...\\\\\nx &\\equiv y_t \\pmod{q_t^{e_t}}\n\\end{matrix}\\right.\n$$\n\nAfter that, we could find a number $x$ holds the original discrete logarithm problem.\n:::\n\nFor a quick sketch of proof, you can visit the chapter 2.9 of the book `An Introduction to Mathematical Cryptography`, that has been introduced before in the document. In general, here is the process of Pohlig-Hellman Algorithm:\n\n![](/images/Pohlig-Hellman-Diagram.svg.png)\n\n```Python\ndef PohligHellman(g, h, p):\n    '''\n    Solve for x where g^x = h mod p\n    '''\n    factorList = list(factor(p-1))\n    X = [] \n    a = []\n    for q, e in factorList: \n        a.append(q^e)\n        # print(q, e)\n        A = g^((p-1)/(q^e)) % p\n        B = h^((p-1)/(q^e)) % p\n        xg = xgcd(A, p) # Extended Euclidean Algorithm\n        A_inv = (xg[1] % p + p) % p\n        # print(A, B)\n        x = []\n        lhs = A^(q^(e - 1)) % p \n        rhs = B^(q^(e - 1)) % p\n        for x0 in range(p):\n            if (pow(lhs, x0, p) == rhs % p):\n                x.append(x0)\n                break \n        for i in reversed(range(e - 1)):\n            degree = sum([x_i*q^j for x_i, j in zip(x, range(e - i))])\n            rhs = (B * (A_inv^degree % p))^(q^i) % p\n            for xi in range(p):\n                if (pow(lhs, xi, p) == rhs % p):\n                    x.append(xi)\n                    break\n        # print(x)\n        X.append(sum([x_i*q^j for x_i, j in zip(x, range(e))]))\n    # print(X, a)\n    x_sol = crt(X, a)\n    assert pow(g, x_sol, p) == h\n    return x_sol\n\ndef test():\n    g = 7\n    p = 433\n    h = 166\n    x_1 = PohligHellman(g, h, p)\n    assert pow(g, x_1, p) == h \n\ntest()\n```\n\n::: {.cell execution_count=2}\n\n::: {.cell-output .cell-output-stdout}\n```\n47\n```\n:::\n:::\n\n\n## Small subgroup confinement\n\nIn the real cases, the prime would be used as the `safe primes`, which have the property that $\\frac{(p - 1)}{2}$ is also a prime. By this, there will be no small primes in factorization of $p - 1$. \n\nHowever, if by some ways, Bob do not change his private key with other conversation, he will be broken by an attack called **Small Subgroup Confinement**. The mechanism of this attack is that, by choosing a prime $p'$ that is both: 1. larger than original, 2. smooth, the attacker will fool Bob to use his $p'$ and then can indeedly solve the Discrete Logaritm on the prime $p'$ rather than $p$. \n\nThis is an example of Subgroup attack.\n\n```Python\nfrom Crypto.Util.number import *\n\ndef safePrime(n):\n    while True: \n        p = getPrime(n)\n        if isPrime((p-1)//2):\n            return p\n\np = safePrime(512)\ng = 2\nx = getRandomRange(1, p-1)\nh = pow(g, x, p)\nprint(g, h, p)\n\n# Assuming we can ask Bob to calculate the exchange...\np_smooth = 11520796732441878515027373358328216938283048199188491628006176039599126895829173510147739451884815667612904500823587381619486714035051906673720821163556657311958585660374139051567952188324884102442385219224493620823660444932593986100650360037352878445543646628098538099116078184566756291092367196511240004251792982479476655806091759279086274692942838381048910186636592077380073350162280464968139585924763388159814562289552926323602180142347053299426189205228246387\nn_smooth = p_smooth - 1\nh_smooth = pow(g, x, p_smooth)\nx_smooth = PohligHellman_ShortCut(g, h_smooth, p_smooth)\nprint(x_smooth)\nprint(x)\n```\n\n::: {.cell execution_count=3}\n\n::: {.cell-output .cell-output-stdout}\n```\n2 23232627927715145862685568329338188710053174168696097126470764275177850578641808809764860546412414219169515413665161651427185191260099570603582784449388 7749379998087896010968255093389721753219171862563309076487333981874026588517919029368648430973371905392515879043689033427998776100901605515584491998175843\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n1412604233344152118025291155071554767608593025971192643130660902487192186944600281627338500606062424801009475967786332663459600515187487467642223244937262\n1412604233344152118025291155071554767608593025971192643130660902487192186944600281627338500606062424801009475967786332663459600515187487467642223244937262\n```\n:::\n:::\n\n\n",
    "supporting": [
      "BreakingDLP_files"
    ],
    "filters": [],
    "includes": {}
  }
}