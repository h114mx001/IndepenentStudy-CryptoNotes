{
  "hash": "5253d52f1f2b007a8bac7faf3b400038",
  "result": {
    "markdown": "# Some attacks on Diffie-Hellman {#sec-Asymmetric}\n\nIn this chapter, we will cover the methods of breaking the Discrete Logarithm - the core of Diffie-Hellman. \n\nFor the uniform, in this chapter, we will try to solve the problem of Discrete Logarithm on $g^x \\equiv h \\pmod p$, with $p, g, h$ are given. \n\n## Baby step, giant step \n\nThis algorithm would be able to break the Discrete Logarithm in the complexity $O(\\sqrt{n})$, for $n$ is the bit-size of $x$. \n\nLet's give $x$ a bound, $0 \\lt x \\le 2^{40}$. \n\nLet $B = 2^{20}$. $x < B^2$, then we can write down $x$ as:\n\n$$\nx = x_0\\cdot B + x_1\n$$\n\nwhere $x_0, x_1 \\in [0, B-1]$\n\n$$\nh \\equiv g^x \\equiv g^{x_0B+x_1} \\equiv (g^B)^{x_0} \\cdot g^{x_1} \\pmod p \n$$\n\nThen, if we divide both side with $g^{x_1}$: \n\n$$\n\\frac{h}{g^{x_1}} \\equiv (g^B)^{x_0} \\pmod p$\n$$\n\nFrom here, we can find the logarithm by building the hash table of every value $\\frac{h}{g^x_1}$; then, finding if we have a collision of $(g^B)^{x_0}$ for both $x_0, x_1 \\in \\mathbb{Z}_p$\n\nIf we have found such a pair $x_0, x_1$, we can compute back $x = x_0B + x_1$.\n```Python\nfrom math import ceil, sqrt\n\n\ndef bsgs(g, h, p):\n    '''\n    Solve for x in h = g^x mod p given a prime p.\n    If p is not prime, you shouldn't use BSGS anyway.\n    '''\n    N = ceil(sqrt(p - 1))  # phi(p) is p-1 if p is prime\n    # Store hashmap of g^{1...m} (mod p). Baby step.\n    tbl = {pow(g, i, p): i for i in range(N)}\n    # Precompute via Fermat's Little Theorem\n    c = pow(g, N * (p - 2), p)\n    # Search for an equivalence in the table. Giant step.\n    for j in range(N):\n        y = (h * pow(c, j, p)) % p\n        if y in tbl:\n            return j * N + tbl[y]\n    # Solution not found\n    return None\n\nprint(bsgs(7894352216, 355407489, 604604729))\n```\n\n\n```{sagemath}\nfrom math import ceil, sqrt\n\ndef bsgs(g, h, p):\n    '''\n    Solve for x in h = g^x mod p given a prime p.\n    If p is not prime, you shouldn't use BSGS anyway.\n    '''\n    N = ceil(sqrt(p - 1))  # phi(p) is p-1 if p is prime\n    # Store hashmap of g^{1...m} (mod p). Baby step.\n    tbl = {pow(g, i, p): i for i in range(N)}\n    # Precompute via Fermat's Little Theorem\n    c = pow(g, N * (p - 2), p)\n    # Search for an equivalence in the table. Giant step.\n    for j in range(N):\n        y = (h * pow(c, j, p)) % p\n        if y in tbl:\n            return j * N + tbl[y]\n    # Solution not found\n    return None\n\nprint(bsgs(7894352216, 355407489, 604604729))\n```\n\n\n\n## Pohlig-Hellman Algorithm\n\n",
    "supporting": [
      "Attacks_DH_files/figure-pdf"
    ],
    "filters": []
  }
}