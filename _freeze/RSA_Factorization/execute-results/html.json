{
  "hash": "7170237e2fb779e43d1cb50b34bf0292",
  "result": {
    "markdown": "# Factorization Attack {#sec-Asymmetric}\n\n## Rainbow attack \n\n[factordb.com](http://factordb.com/) is a database that records the number which were factorized by users around the world. If you are lucky enough, you can try on this database first. \n\nActually, the types of rainbow attack are not rare in InfoSec world. In the process of finding what data hashes a value, we can search the hash. As each hash is different (if it is well-designed), we can find the correct value, if the database has recorded the value.\n\n## Factorization via Difference of Squares \n\nThe first factorization method we will discuss is super-duper simple, based on a very simple method of squares. \n\nAssuming that, for the semiprime $n$, we can have this property:\n\n$$\nn = a^2 - b^2 = (a - b)\\cdot(a+b)\n$$\n\nWith a pair of $a, b$. Indeed, $a-b$ and $a+b$ is the factors we want to searching for. \n\nWith the generation of prime; often, the size of primes are the same (for example, same 512-bit). If the different of two primes are not too much, we can find a solution by this method. \n\n```Python\ndef Fermat(n):\n    '''\n        Factoring of semiprime n = pq if p-q is small\n    '''\n    # As |p-q| is small, sqrt(n) is approximately equal either p or q.\n    # as n = a^2 - b^2, we can search these pairs iteratively.\n    a = ceil(sqrt(n))\n    b2 = a**2 - n\n    b = int(sqrt(b2))\n    while b**2 != b2:\n        a += 1\n        b2 = a**2 - n\n        b = int(sqrt(b2))\n    return a - b, a + b\n\nfrom Crypto.Util.number import getPrime, isPrime\np = getPrime(512)\nq = p \nwhile True: \n    q += 1 \n    if isPrime(q):\n        break \nprint(Fermat(p*q))\n```\n\n::: {.cell execution_count=1}\n\n::: {.cell-output .cell-output-stdout}\n```\n(8063893325433185023797813861938389954124963938827260055890167264220182164332393160011516880879407387195283160843060271734485538182105778197812557684160431, 8063893325433185023797813861938389954124963938827260055890167264220182164332393160011516880879407387195283160843060271734485538182105778197812557684160719)\n```\n:::\n:::\n\n\nThis attack has another enhances methods, that requires understanding of more mathematics about smooth numbers and sieve, so that I will only leave the address here:\n\nChapter 3.6 - 3.7, An Introduction to Mathematical Cryptography (J. Hoffstein, J. Pipher, J. H. Silverman)\n\n## Pollard's p-1 Algorithm \n\nWe have $N = pq$. If we can find a number $L$ satisfies: $p - 1 | L$ and $q - 1 \\nmid L$.\n\nIn that case, we can rewrite $L$ as:\n\n$$\n\\displaylines{L = i(p-1) \\qquad and  \\qquad L = j(q-1) + k}\n$$\n\nChoose a number $a$, which has a huge probability that $GCD(a, n) = 1$. From Fermat's Little Theorem:\n\n$$\n\\displaylines{a^{L} \\equiv a^{i(p-1)} \\equiv 1 \\pmod p \\\\ a^{L} \\equiv a^{j(q-1) + k} \\equiv a^k \\pmod q}\n$$\n\nThen, it means $p | a^L - 1$, and $q \\nmid a^L - 1$, for a huge probability. Then, we can find $p$ easily by computing: \n\n$$\np = GCD(a^L - 1, N)\n$$\n\nTo build the number $L$, if the number $p-1$ has several small prime factors, then it may included in the factorial of $n!$, for $n$ is big enough. \n\nThe Pollard's $p-1$ algorithm is built on this idea. At each step, we will try to find the $GCD(a^{n!}, N)$, and increase to $n+1$. It is remarkable that, the exponent modulo is easier to compute rather than original modulo.\n\n```Python\ndef PollardP_1(N, B=0):\n    '''\n        Find factoring of a semiprime n = pq, where at least p-1 or q-1 has some small prime factors.\n    '''\n    # If the bound is not applied, \n    if not B: B = ceil(sqrt(N))\n    # try each a \n    a = Integers(N).random_element()\n    b = a\n\n    for ell in primes(B):\n        q = 1\n        while q < N: \n            q *= ell \n        b = b^q     # computing the exponent with factorial modulo\n        if b == 1:  \n            return 0\n        d = gcd(b.lift()-1, N) # lift() function to make they in the same group for GCD. \n        if d > 1: \n            return d \n    return 0\nn = 10028219737\np = PollardP_1(n)\nassert n % p == 0\nprint(p, n // p)\n```\n\n::: {.cell execution_count=2}\n\n::: {.cell-output .cell-output-stdout}\n```\n100153 100129\n```\n:::\n:::\n\n\nIn the later chapters, we will look at another factoring algorithm, that lies on the elliptic curve. For further factoring, I recommend you to have a look at the book: `The Joy of Factoring`, from Samuel S. Wagstaff and some chapters in the book `An Introduction to Mathematical Cryptography` I mentioned above. \n\n",
    "supporting": [
      "RSA_Factorization_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}