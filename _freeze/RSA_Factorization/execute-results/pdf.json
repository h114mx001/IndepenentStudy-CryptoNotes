{
  "hash": "89d67857116f6a265c6fa9d7cd3c44de",
  "result": {
    "markdown": "# Factorization Attack {#sec-Asymmetric}\n\n## Rainbow attack \n\n[factordb.com](http://factordb.com/) is a database that records the number which were factorized by users around the world. If you are lucky enough, you can try on this database first. \n\nActually, the types of rainbow attack are not rare in InfoSec world. In the process of finding what data hashes a value, we can search the hash. As each hash is different (if it is well-designed), we can find the correct value, if the database has recorded the value.\n\n## Factorization via Difference of Squares \n\nThe first factorization method we will discuss is super-duper simple, based on a very simple method of squares. \n\nAssuming that, for the semiprime $n$, we can have this property:\n\n$$\nn = a^2 - b^2 = (a - b)\\cdot(a+b)\n$$\n\nWith a pair of $a, b$. Indeed, $a-b$ and $a+b$ is the factors we want to searching for. \n\nWith the generation of prime; often, the size of primes are the same (for example, same 512-bit). If the different of two primes are not too much, we can find a solution by this method. \n\n```Python\ndef Fermat(n):\n    '''\n        Factoring of semiprime n = pq if p-q is small\n    '''\n    # As |p-q| is small, sqrt(n) is approximately equal either p or q.\n    # as n = a^2 - b^2, we can search these pairs iteratively.\n    a = ceil(sqrt(n))\n    b2 = a**2 - n\n    b = int(sqrt(b2))\n    while b**2 != b2:\n        a += 1\n        b2 = a**2 - n\n        b = int(sqrt(b2))\n    return a - b, a + b\n\nfrom Crypto.Util.number import getPrime, isPrime\np = getPrime(512)\nq = p \nwhile True: \n    q += 1 \n    if isPrime(q):\n        break \nprint(Fermat(p*q))\n```\n\n\n```{sagemath}\ndef Fermat(n):\n    '''\n        Factoring of semiprime n = pq if p-q is small\n    '''\n    # As |p-q| is small, sqrt(n) is approximately equal either p or q.\n    # as n = a^2 - b^2, we can search these pairs iteratively.\n    a = ceil(sqrt(n))\n    b2 = a**2 - n\n    b = int(sqrt(b2))\n    while b**2 != b2:\n        a += 1\n        b2 = a**2 - n\n        b = int(sqrt(b2))\n    return a - b, a + b\n\nfrom Crypto.Util.number import getPrime, isPrime\np = getPrime(512)\nq = p \nwhile True: \n    q += 1 \n    if isPrime(q):\n        break \nprint(Fermat(p*q))\n```\n\n\n\nThis attack has another enhances methods, that requires understanding of more mathematics about smooth numbers and sieve, so that I will only leave the address here:\n\nChapter 3.6 - 3.7, An Introduction to Mathematical Cryptography (J. Hoffstein, J. Pipher, J. H. Silverman)\n\n## Pollard's p-1 Algorithm \n\nWe have $N = pq$. If we can find a number $L$ satisfies: $p - 1 | L$ and $q - 1 \\nmid L$.\n\nIn that case, we can rewrite $L$ as:\n\n$$\n\\displaylines{L = i(p-1) \\qquad and  \\qquad L = j(q-1) + k}\n$$\n\nChoose a number $a$, which has a huge probability that $GCD(a, n) = 1$. From Fermat's Little Theorem:\n\n$$\n\\displaylines{a^{L} \\equiv a^{i(p-1)} \\equiv 1 \\pmod p \\\\ a^{L} \\equiv a^{j(q-1) + k} \\equiv a^k \\pmod q}\n$$\n\nThen, it means $p | a^L - 1$, and $q \\nmid a^L - 1$, for a huge probability. Then, we can find $p$ easily by computing: \n\n$$\np = GCD(a^L - 1, N)\n$$\n\nTo build the number $L$, if the number $p-1$ has several small prime factors, then it may included in the factorial of $n!$, for $n$ is big enough. \n\nThe Pollard's $p-1$ algorithm is built on this idea. At each step, we will try to find the $GCD(a^{n!}, N)$, and increase to $n+1$. It is remarkable that, the exponent modulo is easier to compute rather than original modulo.\n\n```Python\ndef PollardP_1(N, B=0):\n    '''\n        Find factoring of a semiprime n = pq, where at least p-1 or q-1 has some small prime factors.\n    '''\n    # If the bound is not applied, \n    if not B: B = ceil(sqrt(N))\n    # try each a \n    a = Integers(N).random_element()\n    b = a\n\n    for ell in primes(B):\n        q = 1\n        while q < N: \n            q *= ell \n        b = b^q     # computing the exponent with factorial modulo\n        if b == 1:  \n            return 0\n        d = gcd(b.lift()-1, N) # lift() function to make they in the same group for GCD. \n        if d > 1: \n            return d \n    return 0\nn = 10028219737\np = PollardP_1(n)\nassert n % p == 0\nprint(p, n // p)\n```\n\n\n```{sagemath}\ndef PollardP_1(N, B=0):\n    '''\n        Find factoring of a semiprime n = pq, where at least p-1 or q-1 has some small prime factors.\n    '''\n    # If the bound is not applied, \n    if not B: B = ceil(sqrt(N))\n    # try each a \n    a = Integers(N).random_element()\n    b = a\n\n    for ell in primes(B):\n        q = 1\n        while q < N: \n            q *= ell \n        b = b^q     # computing the exponent with factorial modulo\n        if b == 1:  \n            return 0\n        d = gcd(b.lift()-1, N) # lift() function to make they in the same group for GCD. \n        if d > 1: \n            return d \n    return 0\nn = 10028219737\np = PollardP_1(n)\nassert n % p == 0\nprint(p, n // p)\n```\n\n\n\n## Lenstra's Elliptic Curve Factorization\n\nWith this method, we are using the concepts of Elliptic Curve. Therefore, you may want to look at the chapters about Elliptic Curve before coming back this chapter.\n\nIn the previous part, in the Pollard's p-1 algorithm, we compute the factorial and hoping it will share the prime factorization with $p - 1$. So, Can we do a 'mimic' of this, as instead of $a^{p-1} \\equiv 1 \\pmod p$, we can do something like this with properties of elliptic curve on finite field addition?\n\n### Intuition\n\n+ If we know $P$, we can calculate $2P$, $3P$, $\\ldots$ easily. Let's see with an example.\n\n$$\nP = (38, 112) \\qquad E: Y^2 = X^3 + 3X + 7\n$$\n+ In here, $x(P), y(P)$ mean the x and y coordinate of P\n\n+ For 2P, from Addition Algorithm:\n$$\n\\begin{aligned}\n\\frac{1}{2y(P)} &= \\frac{1}{224} \\equiv 91 \\pmod {187} \\\\\n\\lambda &= \\frac{3x(P)^2 + A}{2y(P)}\n\\ldots\n\\end{aligned}\n$$\n\n+ For 3P, from Addition Algorithm:\n$$\n\\begin{aligned}\n\\frac{1}{x(2P) - x(P)} &= \\frac{1}{5} \\equiv 75 \\pmod {187} \\\\\n\\lambda &= \\frac{y(2P) - y(P)}{x(2P) - x(P)} = \\frac{14}{5} \\ldots\n\\end{aligned}\n$$\n\n+ We call the value $\\frac{1}{x} \\pmod p$ is **reciprocal**.\n\nAs stated, at each step, in order to determine if we can compute the next $(i+1)P$, we always need to find the inverse modulo of $N$ for some reciprocal value (the denominator of the $\\lambda$)\n\nThen, the idea of Lenstra's Factoring algorithm is just similar to Pollard $p-1$: At each step, we compute \n$$\nP, 2!\\cdot P, 3!\\cdot P, \\ldots\n$$\n\nThere are only 3 cases for reciprocal $d$:\n\n+ If $d = kN$, we need to change the curve and point.\n+ If $d | N$, we have found a prime factor!\n+ Else, continue our computation.\n\n![](/images/elliptic_factoring.png)\n\nThis algorithm works, also because of the Lagrange's theorem. \n\n+ Recall, the Lagrange's theorem stated that if a curve $E$ has order $N$, then any point under this curve will have the order $d$ such $d|N$.\n\n+ As $n = pq$, our original curve $E(\\mathbb{F}_n)$ can be broken into 2 smaller curve of $p, q$, each with the order $N_p, N_q << n$ \n\n+ Then, for any point $P$, we only need to find a number that is divisible by the order of the point $P$, which also divisible by $N_p$. \n\n```Python\np = 6887\nE = EllipticCurve(Zmod(p), [14, 19])\nPoint = E(1512, 3166)\n\ndef pointAddition(point1, point2, p):\n    try:\n        res = point1 + point2 \n    except: \n        reciprocal = (point1[0] - point2[0]) % p \n        d = gcd(reciprocal, p)\n        return (0, 0, d)\n    return res\n\ndef multiplication(k, point, curve, p):\n    r = curve(0, 1, 0) # null \n    tmp = point \n    while k > 0:\n        if k % 2 == 1:\n            r = pointAddition(r, tmp, p)\n            if r[2] > 1:\n                return r\n        tmp = pointAddition(tmp, tmp, p)\n        k //=2 \n    return r\n\nfrom sympy.ntheory import sieve \nfrom random import randint\n\nsieve._reset()\n\ndef LenstraFactorization(n, bound):\n    sieve.extend(bound)\n    while True:\n        g = n \n        point = [0, 0]\n        a, b = 0, 0\n        while (g == n):\n            point = [randint(1, n - 1), randint(1, n - 1)]\n            a = randint(1, n - 1)\n            b = (point[1]^2 - point[0]^3 - a*point[0]) % n\n            g = gcd(4*a^3 + 27*b^2, n)\n        if g > 1:\n            return g\n        curve = EllipticCurve(Zmod(n), [a, b])\n        point = curve(point)\n        q = point\n        for p in sieve:\n            pp = p\n            while pp < bound: \n                q = multiplication(p, q, curve, n)\n                print(q)\n                if q[2] > 1:\n                    return gcd(q[2], n)\n                pp *= p\n        return False\n\nLenstraFactorization(6887, 10000)\n```\n\n\n```{sagemath}\np = 6887\nE = EllipticCurve(Zmod(p), [14, 19])\nPoint = E(1512, 3166)\n\ndef pointAddition(point1, point2, p):\n    try:\n        res = point1 + point2 \n    except: \n        reciprocal = (point1[0] - point2[0]) % p \n        d = gcd(reciprocal, p)\n        return (0, 0, d)\n    return res\n\ndef multiplication(k, point, curve, p):\n    r = curve(0, 1, 0) # null \n    tmp = point \n    while k > 0:\n        if k % 2 == 1:\n            r = pointAddition(r, tmp, p)\n            if r[2] > 1:\n                return r\n        tmp = pointAddition(tmp, tmp, p)\n        k //=2 \n    return r\n\nfrom sympy.ntheory import sieve \nfrom random import randint\n\nsieve._reset()\n\ndef LenstraFactorization(n, bound):\n    sieve.extend(bound)\n    while True:\n        g = n \n        point = [0, 0]\n        a, b = 0, 0\n        while (g == n):\n            point = [randint(1, n - 1), randint(1, n - 1)]\n            a = randint(1, n - 1)\n            b = (point[1]^2 - point[0]^3 - a*point[0]) % n\n            g = gcd(4*a^3 + 27*b^2, n)\n        if g > 1:\n            return g\n        curve = EllipticCurve(Zmod(n), [a, b])\n        point = curve(point)\n        q = point\n        for p in sieve:\n            pp = p\n            while pp < bound: \n                q = multiplication(p, q, curve, n)\n                print(q)\n                if q[2] > 1:\n                    return gcd(q[2], n)\n                pp *= p\n        return False\n\nLenstraFactorization(6887, 10000)\n```\n\n\n\nWith Factorization, SageMath offers a lot of methods that can be used like methods above, or Quadratic Sieve, etc. \nThe full documentation of factorization can be found in:\n\n+ [Integer Factorization](https://doc.sagemath.org/html/en/thematic_tutorials/explicit_methods_in_number_theory/integer_factorization.html#integer-factorization)\n\n+ [Factorization](https://doc.sagemath.org/html/en/reference/structure/sage/structure/factorization.html)\n\nFor further factoring, I recommend you to have a look at the book: `The Joy of Factoring`, from Samuel S. Wagstaff and some chapters in the book `An Introduction to Mathematical Cryptography` I mentioned above. \n\n",
    "supporting": [
      "RSA_Factorization_files/figure-pdf"
    ],
    "filters": []
  }
}