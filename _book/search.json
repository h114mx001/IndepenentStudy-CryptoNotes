[
  {
    "objectID": "UsefulMaths.html#eulers-phi-totient",
    "href": "UsefulMaths.html#eulers-phi-totient",
    "title": "9¬† Toddlers‚Äô Mathematics for PKC",
    "section": "9.1 Euler‚Äôs Phi Totient",
    "text": "9.1 Euler‚Äôs Phi Totient\n\n\n\n\n\n\nNote\n\n\n\nGiven a number \\(n\\), Euler‚Äôs Phi Totient number defines the numbers of natural numbers \\(i\\) (\\(1 \\le i \\lt n\\)) that \\(GCD(i, n) = 1\\)\nThis function is denoted as \\(\\phi(n)\\).\n\n\nExample:  \\(\\phi(20) = 8\\), \\(\\phi(4) = 2, \\phi(5) = 4\\)\nThis totient has some important properties that is useful with RSA:\n\n\n\n\n\n\nImportant Euler‚Äôs Phi Totient Properties:\n\n\n\n\nIf \\(p\\) is a prime, then \\(\\phi(p) = p - 1\\)\nIf \\(GCD(a, b) = 1\\), then \\(\\phi(a\\cdot b) = \\phi(a) \\cdot \\phi(b)\\)\nGiven two numbers \\(a, n\\) where \\(GCD(a, n) == 1\\), then: \\[\na^{\\phi(n)} \\equiv 1 \\pmod n\n\\]"
  },
  {
    "objectID": "UsefulMaths.html#inverse-modulo",
    "href": "UsefulMaths.html#inverse-modulo",
    "title": "9¬† Toddlers‚Äô Mathematics for PKC",
    "section": "9.2 Inverse modulo",
    "text": "9.2 Inverse modulo\n\n\n\n\n\n\nInverse modulo n\n\n\n\nGiven a number \\(a\\), the inverse modulo \\(n\\) of \\(a\\) is the number \\(x\\) where:\n\\[\nax \\equiv 1 \\pmod{n}\n\\]\nThis inverse should exist if \\(GCD(a, n) = 1\\)"
  },
  {
    "objectID": "UsefulMaths.html#fermats-little-theorem",
    "href": "UsefulMaths.html#fermats-little-theorem",
    "title": "9¬† Toddlers‚Äô Mathematics for PKC",
    "section": "9.3 Fermat‚Äôs Little Theorem",
    "text": "9.3 Fermat‚Äôs Little Theorem\n\n\n\n\n\n\nFermat‚Äôs Little Theorem\n\n\n\nGiven two numbers \\(a, p\\) where \\(GCD(a, p) = 1\\), then \\(a^{p} \\equiv a \\pmod{p}\\). Consequently, \\(a^{p-1} \\equiv 1 \\pmod{p}\\)"
  },
  {
    "objectID": "UsefulMaths.html#discrete-logarithm",
    "href": "UsefulMaths.html#discrete-logarithm",
    "title": "9¬† Toddlers‚Äô Mathematics for PKC",
    "section": "9.4 Discrete Logarithm",
    "text": "9.4 Discrete Logarithm\nGiven \\(a, h, n\\) where there exists a number \\(x\\) that \\(a^x \\equiv h \\pmod{n}\\), the discrete logarithm problem is the process of finding the suitable number \\(x\\) in \\(\\mathbb{Z}_n\\)."
  },
  {
    "objectID": "UsefulMaths.html#some-abstract-algebra",
    "href": "UsefulMaths.html#some-abstract-algebra",
    "title": "9¬† Toddlers‚Äô Mathematics for PKC",
    "section": "9.5 Some Abstract Algebra",
    "text": "9.5 Some Abstract Algebra\nIn here, I will introduce several simple concepts of group, generator, order of a group and order of a member of the group. Remember, these definitions are not formal, and it is written for more easily understanding.\n\n9.5.1 Group\nFor simplicity, a group \\(G\\) is a set of elements, that supports an operation \\(\\star\\). In the group, the operation has the following properties:\n\nIdentity: There is an element \\(e \\in G\\) such that: \\(e\\star a = a \\star e = a\\) for every \\(a \\in G\\). \\(e\\) is called as the identity element.\nInverse: For \\(\\forall a \\in G\\), there is a unique \\(a^{-1}\\) where: \\(a \\star a^{-1} = e\\). \\(a^{-1}\\) is called as inverse.\nAssociative: For every \\(a, b, c \\in G\\), \\(a \\star (b \\star c) = (a \\star b) \\star c\\).\nCommutative: \\(a \\star b = b \\star a\\). A commutative group is also called abelian group.\n\nDuring the RSA and Diffie-Hellman (DH), we will talk much about the group \\(\\mathbb{Z}_p\\). You can verify the properties yourself.\nA group with finite number of elements is called as a finite group.\n\n\n9.5.2 Generator\nTake the example of a group \\(\\mathbb{Z}_{13}\\). If we compute number \\(2^x\\) where \\(0 \\le x \\lt p - 1\\), we can have a set:\n\\[\n\\{2^x\\} = \\{1, 2, 4, 8, 3, 6, 12, 11, 9, 5, 10, 7\\}\n\\]\nThis set is \\(\\mathbb{Z}_{13}\\). However, if we take another number, for example, 5:\n\\[\n\\{5^x\\} = \\{1, 5, 12, 8\\}\n\\]\n\\(2\\) is the generator of group \\(G = \\mathbb{Z}_{13}\\), but \\(5\\) isn‚Äôt.\nThen, generator of a group is the element that can generate the group, with the process you see above (in this multiplicative group, it can be done via exponent).\n\n\n9.5.3 Order\nCome back to our example above, as \\(2\\) can generate the set of 12 elements, the order of \\(2\\) in the group \\(G\\) is \\(12\\). Indeed, the order of \\(5\\) is \\(4\\).\nDenoted the number \\(d\\) as the order of the group. In some group, we cannot find \\(d_a\\) for every \\(a\\) in group, then these \\(a\\) are called as having infinite order.\nAlso, the order of the generator is assigned to the order of the group.\nThere are some properties with the order, that will be mentioned in some attacks on the DH and RSA:\n\n\n\n\n\n\nProperties of order in finite group\n\n\n\nLet \\(G\\) be a finite group. It has the order \\(n = |G|\\). Let \\(a \\in G\\) and the order of \\(a\\) is \\(d\\).\n\nThen, every element of \\(G\\) has finite order.\nIf there exists a number \\(k\\) where \\(a^k \\equiv e\\), then \\(d | k\\).\n(Lagrange‚Äôs theorem). \\(d | n\\) and \\(a^n \\equiv e\\)."
  },
  {
    "objectID": "Preface.html#some-words-before-going",
    "href": "Preface.html#some-words-before-going",
    "title": "Summary",
    "section": "Some words before going",
    "text": "Some words before going\n‚ÄúHave you used Cryptography?‚Äù I have asked this question to several of my friends and some of them would say, no. But look around, the website you love has a way to secretly communicate with you everyday, through some web protocols with cryptography. You may reveal everything to the hacker with only one tap of your credit card when you do some shopping without the magic of Cryptography. Some latest trend, Blockchain: Cryptocurrency, NFTs, Distributed stuffs, etc.; have its cores are cryptographic protocols to preserve the integrity. Even somethings does not seems to need Cryptography, like AI, recently have some usage of it to preserve the privacy in training dataset.\nTherefore, I would really appreciate that you choose me and my document as a first playground for your crypto knowledge!!!"
  },
  {
    "objectID": "Preface.html#brief-summary",
    "href": "Preface.html#brief-summary",
    "title": "Summary",
    "section": "Brief summary",
    "text": "Brief summary\nA brief summary of the books:\n\n‚ÄúSymmetric Cryptography‚Äù: As its name, we will have a walkthrough some fields of Symmetric Cryptography from the very historical (and completely) broken to the newest that are used in your daily Internet surfing.\n‚ÄúAsymmetric Cryptography‚Äù: This part will look into the constructions of many famous cryptography scheme that is also the deliverer for your symmetric cryptography and validation. !!! Warning: Many Maths!\n‚ÄúHash functions‚Äù: Integrity will mostly mention in this field, and some examples of how to playing with some hacks to break the integrity!\n‚ÄúAppendices‚Äù: Some other tools/guides for you to playing with the material of the book and also further games."
  },
  {
    "objectID": "Preface.html#philosophy",
    "href": "Preface.html#philosophy",
    "title": "Summary",
    "section": "Philosophy",
    "text": "Philosophy\nThe aim of this book is guilding you to start with crypto, rather than a cheatsheet for you to copy the snipset into any cryptography challenges in CTFs. Therefore, the basics of SageMath/Python will be mentioned in the book, but not the all attacks‚Äô implementations. I know that there are many available samples on GitHub; however, gaining experiences by playing around with debugging, ‚Äòmath‚Äô-ing, and programming is better, rights?\nHowever, do not afraid about the hard problems. At any point of this book, you will find some exercises (that I find it should work for gaining your skills) to practice with. Also, do not afraid to contact me via social medias üòé!\n\n\n\n\n\n\nTip\n\n\n\nLet‚Äôs write something (as clear as you can) about what you want to learn or love about Cryptography and what do you expect this book has. 100% I can give you all the stuff you need, but I am sure you will find them out if you REALLY want to finish (and extend) your checklist!\n\n\nThat‚Äôs enough for the text! Let‚Äôs gooooo!!!!."
  },
  {
    "objectID": "MathBackground.html#note-on-code-execution",
    "href": "MathBackground.html#note-on-code-execution",
    "title": "Mathematical Background",
    "section": "Note on code execution",
    "text": "Note on code execution\nAs this book uses SageMath as its main environment, I suggest you start with installing the tool first. The complete guide is available in their website.\nIf you are using Windows, you should install Windows Subsystem Linux (WSL), and then install inside your WSL system. As SageMath stops release the binary for Windows, your version of SageMath will not be updated if you choose this way.\nAs some limit of Quarto don‚Äôt allow us to both execute the SageMath code and syntax highlighting them (or I have not figured how to do it), you can see this example:\n\"\"\"\n    A test program on SageMath. NOTE: same syntax \n    with Python ;)\n\"\"\"\nprint(\"Hello World\")\nfor i in range(0, 10):\n    print(i)\n\n\nHello World\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nSome lines after the code are the output."
  },
  {
    "objectID": "MathBackground.html#in-this-chapter",
    "href": "MathBackground.html#in-this-chapter",
    "title": "Mathematical Background",
    "section": "In this chapter",
    "text": "In this chapter\n\nMathematical Notations"
  },
  {
    "objectID": "Maths_Notation.html#special-sets",
    "href": "Maths_Notation.html#special-sets",
    "title": "1¬† Mathematical Notation",
    "section": "1.1 Special sets",
    "text": "1.1 Special sets\n\n\\(\\mathbb{C}\\): Complex numbers\n\\(\\mathbb{R}\\): Real numbers\n\\(\\mathbb{Z}\\): Integers\n\\(\\mathbb{Q}\\): Rational numbers\n\\(\\mathbb{N}\\): Natural numbers\n\\(\\mathbb{Z}/n\\mathbb{Z}\\): Set of integers mod \\(n\\)\n\nAn example of SageMath on these guys:\n\"\"\"\nThe following SageMath commands to call a set: \n\"\"\"\nCC # Complex numbers with 53-bit of precision.\nRR # Real numbers with 53-bit of precision.\nZZ # Integer Ring. \nQQ # Rational Field.\nNN # Non-negative integer semi-ring.\nZmod(11) # aka Integers(11) or `IntegerModRing(11)`: Ring of modulo 11\n\nThe unit groups: \\(R^{\\times}\\) or \\(R^{*}\\)\nFinite fields with \\(q\\) elements: \\(\\mathbb{F}_q\\)\nGeneral field: \\(k\\)\nAlgebraic closure of a field: \\(\\bar{k}\\)\n\nExample of SageMath codes:\nGF(11)\n\nGF(11)\n\nFinite Field of size 11\n\n\nGF(11).algebraic_closure()\n\nGF(11).algebraic_closure()\n\nAlgebraic closure of Finite Field of size 11\n\n\nSome interesting function for you to play with:\n\"\"\"\n`.parent()`: finding which field an element belongs to\n\"\"\"\nx = 7\nprint(x.parent())\n\nx = 3.5\nprint(x.parent())\n\nx = 7\nprint(x.parent())\n\nx = 3.5\nprint(x.parent())\n\nInteger Ring\nReal Field with 53 bits of precision\n\n\n\"\"\"\n`.lift()`: Lift an element from its parent to its... grandparent?\ne.g: from quotient ring Q (R/I) -> R\n\"\"\"\nR = ZZ \nRI = Zmod(11)\nx = RI(5)\n\nprint(x.parent())\n\ny = x.lift()\nprint(y.parent())\n\nprint(y in R)\n\nR = ZZ \nRI = Zmod(11)\nx = RI(5)\nprint(x.parent())\n\ny = x.lift()\nprint(y.parent())\nprint(y in R)\n\nRing of integers modulo 11\nInteger Ring\nTrue"
  },
  {
    "objectID": "Maths_Notation.html#other-important-ones",
    "href": "Maths_Notation.html#other-important-ones",
    "title": "1¬† Mathematical Notation",
    "section": "1.2 Other important ones",
    "text": "1.2 Other important ones\n\n\\(Pr(A)\\) means the probability of an event \\(A\\) to happen. Sometimes, you may see the notation \\(Pr[A]\\) and \\(P(A)\\) also."
  },
  {
    "objectID": "GuideOnSource.html#introduction",
    "href": "GuideOnSource.html#introduction",
    "title": "2¬† Guide on Mathematics sources",
    "section": "2.1 Introduction",
    "text": "2.1 Introduction\nAs you are working with computations of ciphering and deciphering, being comfortable with the Maths here is the best! In terms of the purpose of this document, we will not go too deep in any Mathematics here. However, here are some books that I think may help you a lot when studying some first cryptos:\nAlso, before working with the few next chapters, you should be comfortable with:\n\nModular Arithmetic (Concepts of modulo, GCD, etc.)\nPython (if you are good at SageMath, it‚Äôs really appreciated!)\nSome simple binary operations (AND, OR, XOR, NOT, etc.)\nLearning something cool!"
  },
  {
    "objectID": "Foundations.html",
    "href": "Foundations.html",
    "title": "Foundations",
    "section": "",
    "text": "Most of the cases, you do not want to look at a piece where every single letters are abstract digits and numbers but images, videos or at least readable text. However, cryptography does not work quite well with the ordinary letters themselves; therefore, we need encoding to change our letter to some computable forms (like binary, decimal, etc.)\nIn this part, we will have a look at some topics:"
  },
  {
    "objectID": "Encoding.html#introductions",
    "href": "Encoding.html#introductions",
    "title": "3¬† Encoding",
    "section": "3.1 Introductions",
    "text": "3.1 Introductions\nAs a two-year (or more) CTF players, I have not see any challenges that works too much on the encoding (As they are standardized). Some may appear in challenges of Web or Pwn, where the format of the data matters. In this section, I will introduce several common types of encoding for you!"
  },
  {
    "objectID": "Encoding.html#ascii",
    "href": "Encoding.html#ascii",
    "title": "3¬† Encoding",
    "section": "3.2 ASCII",
    "text": "3.2 ASCII\nASCII is 7-bit encoding standard, where each letter is assigned with a number from 0-127. Besides this ASCII table, we also have an extended ASCII, where 256 characters are encoded. You can have a look at ASCII Table to see it clearer.\ns = \"Hello World\"\nprint([ord(c) for c in s])\n\n\n[72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]"
  },
  {
    "objectID": "Encoding.html#hex",
    "href": "Encoding.html#hex",
    "title": "3¬† Encoding",
    "section": "3.3 Hex",
    "text": "3.3 Hex\nHex stands for Hexadecimal, i.e.¬†base 16. Basically, you can understand Hex as a version of ASCII but in hexadecimal rather than decimal.\ns = \"Hello World\"\nprint([hex(ord(c)) for c in s])\nprint(bytes(s, encoding='utf-8').hex())\n\n\n['0x48', '0x65', '0x6c', '0x6c', '0x6f', '0x20', '0x57', '0x6f', '0x72', '0x6c', '0x64']\n48656c6c6f20576f726c64"
  },
  {
    "objectID": "Encoding.html#base64",
    "href": "Encoding.html#base64",
    "title": "3¬† Encoding",
    "section": "3.4 Base64",
    "text": "3.4 Base64\nUsing Base64 encoding, you can represent binary data as ASCII string, with an alphabet of 64 characters. Some other versions of Base64, like Base58 (Using in Bitcoin, remove some ‚Äòlook-the-same‚Äô character like l (normalcase l) and I (uppercase i)) are alse used widely.\nIn Python, you can use the library base64 for working with this encoding.\ns = \"Hello World\"\nimport base64\nb64enc = base64.b64encode(s)\nprint(b64enc)\nprint(base64.b64decode(b64enc))\n\n\nb'SGVsbG8gV29ybGQ='\nb'Hello World'"
  },
  {
    "objectID": "Encoding.html#bignum-and-bytes",
    "href": "Encoding.html#bignum-and-bytes",
    "title": "3¬† Encoding",
    "section": "3.5 Bignum and Bytes",
    "text": "3.5 Bignum and Bytes\nIf you want to encrypt a word (‚ÄúHELLO‚Äù, for example); most of the case, you can‚Äôt apply encryption directly on it. A solution is that: concatenate the hex value of each characters. For example:\nmessage: HELLO\nascii bytes: [72, 69, 76, 76, 79]\nhex bytes: [0x48, 0x45, 0x4c, 0x4c, 0x4f]\nbase-16: 0x48454c4c4f\nbase-10: 310400273487 \nWhen working with these bignums, a Python library PyCryptodome provides two functions to convert back and forth:\ns = b\"Hello World\"\nprint(s.hex())\nfrom Crypto.Util.number import long_to_bytes, bytes_to_long\n# The usage of command\nprint(bytes_to_long(s))\n\n# Compare with the hex value\nprint(hex(bytes_to_long(s)))\n\n# Decoding\nprint(long_to_bytes(bytes_to_long(s)))\n\n\n48656c6c6f20576f726c64\n87521618088882533792115812\n0x48656c6c6f20576f726c64\nb'Hello World'\n\n\nAlso, there are some forms of encoding like URL Encoding, which uses a lot in our hyperlinks. You can always search them, when you need it xD."
  },
  {
    "objectID": "Symmetric.html#block-cipher",
    "href": "Symmetric.html#block-cipher",
    "title": "Symmetric Cryptography",
    "section": "Block cipher",
    "text": "Block cipher\nIn Cryptography, Block Cipher is a symmetric cryptographic algorithm that divides a plaintext into multiple blocks of equal length, and encrypts/decrypts each block separately. This pretty much same as some classical ciphers you may hear about, like Caesar, except a whole block is substituted rather than a single character.\nWith supports of some modes of operations, we could have different ways of encrypt/decrypt, and also even change the block cipher into stream cipher, where each characters are substituted."
  },
  {
    "objectID": "ECB.html#ecb",
    "href": "ECB.html#ecb",
    "title": "4¬† Modes of operations & ECB",
    "section": "4.1 ECB",
    "text": "4.1 ECB\nElectronic Code Book is the simplest mode of operation, where each block of plaintext is independently encrypted/decrypted.\n\n\n\nECB\n\n\nIndeed, besides its simplicity, ECB can bring lots of hazards. According to the independent process between each block, the data pattern is not well-hidden with ECB, with this example below:\n\n\n\nTux_ECB\n\n\nYou can try ECB encryption process with the library PyCryptodome with this example:\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad, unpad\n\n\nkey = b'sixteen byte key' # should be 16-byte key\nAESMachine = AES.new(key, AES.MODE_ECB)\ndata = b'I am b1b1 s4y 0h y3@h!'\n# remember to pad the data!\ncipher = AESMachine.encrypt(pad(data, 16))\ndecrypt = AESMachine.decrypt(cipher)\n\nprint(cipher)\nprint(decrypt)\n\n\nb\"\\x1a\\xcbv]y\\x7f\\xe6\\x9c\\xe3I'F\\xe5e)\\xef;\\xbb#>w_\\x97\\x0f\\x8a\\xfff\\xbd\\x88\\xb3n\\xcb\"\nb'I am b1b1 s4y 0h y3@h!\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'\n\n\n\n\n\n\n\n\nImportant\n\n\n\nIn most of AES modes of operations, we need to pad the data with proper size. As you see in some next chapters, AES will encrypt each 16-byte block of the message at one time; therefore, we need to pad the data as 16-byte block. The function pad(data, 16) as you see in the code is one very good padding scheme, PKCS7"
  },
  {
    "objectID": "CBC.html",
    "href": "CBC.html",
    "title": "5¬† CBC",
    "section": "",
    "text": "From now on, every mode of operations we see will make our blocks dependant to each other, by some ways.\nThe Cipher Block Chaining mode will make every block encrypted after it has been XORed with its preceding cipher block. With the first block, we add in a Initialization vector (IV) to work as its preceding block.\n\n\n\nCBC Encryption\n\n\nThen, the decryption will be reversed:\n\n\n\nCBC Decryption\n\n\nWe can formulate the above processes as:\nWith \\(C_0 = IV\\) \\[\n\\displaylines{C_i = E(P_i \\oplus C_{i-1})\\\\P_i = D(C_i) \\oplus C_{i-1}}\n\\]\nIndeed, it does not (and also never) means we use CBC then our cipher is good.\nYou can try AES CBC by this piece of code:\nfrom Crypto.Cipher import AES \nfrom Crypto.Util.Padding import pad, unpad \n\nkey = b'a'*16\ndata = b'hello world this is bibi' \niv = b'yellow submarine'\n\nAESMachine = AES.new(key, AES.MODE_CBC, iv)\ncipher = AESMachine.encrypt(pad(data, 16))\nprint(cipher)\n\nAESMachine = AES.new(key, AES.MODE_CBC, iv)\ndecrypt = AESMachine.decrypt(cipher)\nprint(decrypt)\n\n\nb'\\x18|\\x95M\\xc4iw\\xbc\\x13<2\\xaf\\x0e\\n\\xe4d{Rm!/B\\xc4sB\\xbc\\x07\\xc7@\\xa5\\x8e\\xd1'\nb'hello world this is bibi\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08'\n\n\n\n\n\n\n\n\nRecommended challenges:\n\n\n\n\nLazy CBC\nFlipping Cookies"
  },
  {
    "objectID": "OFB_CFB.html#ofb",
    "href": "OFB_CFB.html#ofb",
    "title": "6¬† OFB & CFB",
    "section": "6.1 OFB",
    "text": "6.1 OFB\nOutput Feedback (OFB) encrypts the Initialization Vector for the first time, and the previous encrypted version of it as the first XOR block. then, the plaintext block will be XOR-ed with this one.\n\n\n\nOFB\n\n\nWe can formulate the process as:\nIf ‚ÄúXOR block‚Äù is \\(O\\), plaintext is \\(P\\), ciphertext is \\(C\\):\n\\[\n\\displaylines{O_0 = IV \\\\ O_i = E(O_{i-1}) \\\\ C_i = P_i \\oplus O_i \\\\ P_i = C_i \\oplus O_I}\n\\]\nAs you can see, the ciphertext and plaintext are symmetric, due to symmetry properties of OFB.\n\n\n\n\n\n\nSpot\n\n\n\nCan you spot a weakness if the advisery know the ciphertext and the IV used in this ciphertext?"
  },
  {
    "objectID": "OFB_CFB.html#cfb",
    "href": "OFB_CFB.html#cfb",
    "title": "6¬† OFB & CFB",
    "section": "6.2 CFB",
    "text": "6.2 CFB\nCipher Feedback (CFB) is quite not the same with OFB, except it uses the ciphertext of previous block as input of current block. (In OFB, we use the previous block cipher output)\n\n\n\nCFB_enc\n\n\n\n\n\nCFB_dec\n\n\nAgain, we can formulate the process as:\n\\[\n\\displaylines{C_0 = IV \\\\ C_i = P_i \\oplus E(C_{i-1}) \\\\ P_i = C_i \\oplus E(C_{i-1})}\n\\]\n\n\n\n\n\n\nTip\n\n\n\nCan you try this version by yourself, using the snipset in two part above?"
  },
  {
    "objectID": "CTR.html",
    "href": "CTR.html",
    "title": "7¬† CTR",
    "section": "",
    "text": "The final mode of operation we will introduce will have a little bit different. While every other mode will have a fixed ciphertext for each plaintext, CTR will provide a different one every time we create new ciphers. This can be done because of the mechanism of nonce and counter (the name Counter Mode of CTR said it all).\nIn CTR, the nonce acts the same as IV in other modes, while the counter will be altered each time new message is required."
  },
  {
    "objectID": "AESBasic.html#introduction",
    "href": "AESBasic.html#introduction",
    "title": "8¬† Basics about AES",
    "section": "8.1 Introduction",
    "text": "8.1 Introduction\nIn some decades ago, the needs of encryption in both governmental, military and also basic data arose around the world. Therefore, many algorithms have been developed. Some among them survive until today and we have AES.\nFor a clear introduction about AES, I would refer you to read it in the Wikipedia page of AES."
  },
  {
    "objectID": "AESBasic.html#algorithms",
    "href": "AESBasic.html#algorithms",
    "title": "8¬† Basics about AES",
    "section": "8.2 Algorithms",
    "text": "8.2 Algorithms\nThe encryption of AES can be broken into two parts, the Key Schedule and the Encryption. Based on your mode (AES-256, for example), your key will be required to have this length. At right now, AES-256 is still super good for any of your normal encryption.\n\n8.2.1 Key Schedule\nThe Key Schedule process is required to break the key into small sub-keys, which will be used in each round of AES. The Key Schedule‚Äôs implementation is worked by the operations under Galois Field \\(GF(2^8)\\). Explaining this process would take lots of time because of the Abstract Algebra it‚Äôs related, so I would give a link if you really want to learn about it:\nAES Key Schedule"
  },
  {
    "objectID": "AESBasic.html#processes-of-an-aes",
    "href": "AESBasic.html#processes-of-an-aes",
    "title": "8¬† Basics about AES",
    "section": "8.3 Processes of an AES",
    "text": "8.3 Processes of an AES\n\n\n\nAES Structure\n\n\nAs you see here, default AES will have 10 rounds, with these subprocess:\n\nAddRoundKey: The sub-key from Key Schedule will be XOR-ed with the 16-byte block of plaintext.\n\n\n\n\n\n\n\nSubBytes: Each position of the block will be substituted with another byte, via implementation of Sbox. The Sbox is just a sophiticated way to substitute, rather than poorer one like in classical cipher, like Caesar. Again, the implementation is required some advanced math so we can assume that, this Sbox will never leak any bytes.\n\n\n\n\n\n\n\nShiftRows: This step is super simple, as except the first row, every other rows will be left-shifted 1, 2, and 3 positions.\n\n\n\n\n\n\n\nMixColumn: At this step, every column of the block will be fixed after a matrix multiplication under Galois Field.\n\n\n\n\n\n\nOne series that I really recommended is AES introduction from the website CryptoHack. You could also play others about AES here."
  },
  {
    "objectID": "Asymmetric.html",
    "href": "Asymmetric.html",
    "title": "Asymmetric Cryptography",
    "section": "",
    "text": "Welcome to the second part of this guide! With the previous part, we have a quick walkthrough for every part of symmetric cryptography. As you may recognize, the main uncomfortable thing of symmetric cryptography is that both party need to have an agreement on a same key. During the 1970s, some first attempts to remove this barrier has been successful. Since then, two party can use secured protection over their conversations.\nTwo main applications of asymmetric cryptography is:\n\nPublic key encryption: where Alice will use a public key to allow other people send messages to her, and another private key for her to read the ciphertext.\n\n\n\n\n\n\n\nDigital signature: when Alice create some document, she can ‚Äòsign‚Äô into the document to verify her as the true owner. Any other people can verify it easily, just by some simple calculations.\n\n\n\n\n\n\nMore than that, Asymmetric cryptography can be used as a key sharing scheme (like Diffie-Hellman) that can be used in sharing the common key for the Symmetric Cryptography.\n\n\n\n\n\nThe anatomy of Asymmetric Cryptography is just like that. During this part, three significants cryptosystem will be demonstrated: RSA, Diffie-Hellman Key Exchange and a little bit on simple digital signature.\nIn the last chapters, the mechanism of Elliptic Curve Cryptography will also be included."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CryptoBook",
    "section": "",
    "text": "Welcome\nThis ‚ÄòCryptoBook for n00b1es‚Äô is a beginner guide, with the main purpose is for any beginners who want to poke around with Cryptography in a practical way. This book is released as a result of an Independent Study course about basic Cryptography, conducted by Nguyen Tuan Anh (h114mx001, supervised by Professor Wray Buntine); from College of Engineering and Computer Science, VinUniversity.\nThis book targets the newcomers to Cryptography field, from guiding you from basic implementation of some cryptography schemes, to some more advance and popular ones. From perspectives of a crypto learner, I included a lot of practical work (implementations, explanation, etc.) about how to work and/or break some usual cryptosystems. Also, you will find yourself more familiar with some most useful tools in your cryptography work (in this book, I choose Python and a CAS build on it, SageMath as main tools).\nThis website and book will always be free to access, licensed under the CC BY-NC-ND 3.0 license. Currently, the only way for you to get a physical copy of this document is print my website out.\nIndeed, this book will not end here, updated version will continue (based on my skills and your demands too!). After this (final) version, you can expect next versions of the document."
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "CryptoBook",
    "section": "Acknowledgements",
    "text": "Acknowledgements"
  },
  {
    "objectID": "RSA.html",
    "href": "RSA.html",
    "title": "10¬† RSA",
    "section": "",
    "text": "Let‚Äôs go into the first cryptosystem in this section! RSA, named after its three inventors, is probably one of the most popular cryptosystem we are using.\nThe RSA algorithm is easy to understand.\nAssuming that, our Alice, want to establish a secure way to talk to the outsiders. She will choose her two prime numbers: \\(p\\), \\(q\\), based on the length of ciphertext she want. For example, in RSA-512, the \\(p\\) and \\(q\\) is 512-bit long.\nThen, she compute her \\(n = p\\cdot q\\). Then, the Euler‚Äôs totient for this number is \\[\n\\phi(n) = (p-1)\\cdot (q-1)\n\\]\nNext, she will choose a number \\(e\\), in a way that \\(GCD(e, \\phi(n)) = 1\\). The pair \\((e, n)\\) will be her public key.\nThen, she will compute a number \\(d = e^{-1} \\pmod{\\phi(n)}\\). Then, the public-key will be \\((e, n)\\) and private-key be \\((d, n)\\).\nFor anyone who want to send Alice something, they would compute the ciphertext: \\[\nc \\equiv m^{e} \\pmod n\n\\]\nWith this ciphertext, Alice will use her private key, \\(d\\) to decrypt:\n\\[\nc^d \\equiv (m^e)^d \\equiv m^{ed} \\pmod n\n\\]\nAs we know, \\(ed \\equiv 1 \\pmod{\\phi(n)}\\), then, we can rewrite it as \\(ed = k\\phi(n)+1\\)\nAlso, if \\(GCD(m, n) = 1\\) (almost 100% as the two only factors of \\(n\\) are \\(p, q\\)), then \\(m^{\\phi(n)} \\equiv 1 \\pmod n\\), we can rewrite as:\n\\[\nm^{ed} \\equiv m^{k\\phi(n)+1} \\equiv m^{k\\phi(n)} \\cdot m \\equiv 1 \\cdot m \\equiv m \\pmod{n}\n\\]\nThe security of RSA, come from the trapdoor function of factorizing the large semiprime \\(n\\), from its two huge factors \\(p, q\\). The direct attacks on RSA is on this public key, then finding back the private key for the plaintext.\nNormal, in CTF, the target for us is to find the backdoor in the cryptosystem, and from the given ciphertext, find back the answer.\nThe next chapter will talk about some beginner-intermediate level of attack RSA.\n\n\n\n\n\n\nRSA in real cases\n\n\n\nBreaking the RSA in both real life and in CTFs required more than these attacks. According to the structures of cryptosystem, there will be more vulnerabilities than listed ones in this documentation."
  },
  {
    "objectID": "Attacks_RSA.html#factorizaion",
    "href": "Attacks_RSA.html#factorizaion",
    "title": "11¬† Review several attacks on RSA",
    "section": "11.1 Factorizaion",
    "text": "11.1 Factorizaion\nThe first thing we may want to try is breaking RSA from its root: the semiprime \\(n\\). With the factorization of \\(n\\), we can break the RSA scheme anytimes. In here, we will talk, specifically, how to break the semiprime \\(n = p\\cdot q\\), rather than working in the factorization in general.\nFactorization"
  },
  {
    "objectID": "Attacks_RSA.html#improper-choices-of-parameters",
    "href": "Attacks_RSA.html#improper-choices-of-parameters",
    "title": "11¬† Review several attacks on RSA",
    "section": "11.2 Improper choices of parameters",
    "text": "11.2 Improper choices of parameters\nFrom the introduction chapter, we know that we need to chooses the public key and private key for every RSA. The wrong choices may lead into a quite severe attacks. Also, the process of generating primes may also lead to the problem. We will include one case here."
  },
  {
    "objectID": "Attacks_RSA.html#side-channel-attack",
    "href": "Attacks_RSA.html#side-channel-attack",
    "title": "11¬† Review several attacks on RSA",
    "section": "11.3 Side-channel attack",
    "text": "11.3 Side-channel attack\nBasically, encryption is just a calculation process. The side-channel attacks will look into some physical time series when performing the tasks of RSA, then tell us a way to break the cryptosystem by these data."
  },
  {
    "objectID": "RSA.html#digital-signature-by-rsa",
    "href": "RSA.html#digital-signature-by-rsa",
    "title": "10¬† RSA",
    "section": "10.1 Digital Signature by RSA",
    "text": "10.1 Digital Signature by RSA\nFrom RSA, we can build a digital signature scheme, which is not too different from our original RSA.\nFor example, we need to sign a data with value of \\(m\\). With the same public-private key as in RSA, we can compute our signature as:\n\\[\ns \\equiv m^d \\pmod n\n\\]\nIf someone want to verify \\(s\\), they only needs to calculate:\n\\[\ns' \\equiv s^e \\equiv m^{ed} \\equiv m \\pmod n\n\\]\nSome adversary can only hijack us, if they can control the private key \\(d\\), which is impractical in current theme of RSA."
  },
  {
    "objectID": "RSA_Factorization.html#rainbow-attack",
    "href": "RSA_Factorization.html#rainbow-attack",
    "title": "12¬† Factorization Attack",
    "section": "12.1 Rainbow attack",
    "text": "12.1 Rainbow attack\nfactordb.com is a database that records the number which were factorized by users around the world. If you are lucky enough, you can try on this database first.\nActually, the types of rainbow attack are not rare in InfoSec world. In the process of finding what data hashes a value, we can search the hash. As each hash is different (if it is well-designed), we can find the correct value, if the database has recorded the value."
  },
  {
    "objectID": "RSA_Factorization.html#factorization-via-difference-of-squares",
    "href": "RSA_Factorization.html#factorization-via-difference-of-squares",
    "title": "12¬† Factorization Attack",
    "section": "12.2 Factorization via Difference of Squares",
    "text": "12.2 Factorization via Difference of Squares\nThe first factorization method we will discuss is super-duper simple, based on a very simple method of squares.\nAssuming that, for the semiprime \\(n\\), we can have this property:\n\\[\nn = a^2 - b^2 = (a - b)\\cdot(a+b)\n\\]\nWith a pair of \\(a, b\\). Indeed, \\(a-b\\) and \\(a+b\\) is the factors we want to searching for.\nWith the generation of prime; often, the size of primes are the same (for example, same 512-bit). If the different of two primes are not too much, we can find a solution by this method.\ndef Fermat(n):\n    '''\n        Factoring of semiprime n = pq if p-q is small\n    '''\n    # As |p-q| is small, sqrt(n) is approximately equal either p or q.\n    # as n = a^2 - b^2, we can search these pairs iteratively.\n    a = ceil(sqrt(n))\n    b2 = a**2 - n\n    b = int(sqrt(b2))\n    while b**2 != b2:\n        a += 1\n        b2 = a**2 - n\n        b = int(sqrt(b2))\n    return a - b, a + b\n\nfrom Crypto.Util.number import getPrime, isPrime\np = getPrime(512)\nq = p \nwhile True: \n    q += 1 \n    if isPrime(q):\n        break \nprint(Fermat(p*q))\n\n\n(11684157899954979996979082866262653803586498995495766081693122889492206114926204346355410010887353071582115230205128010020201869047949018633033315023637067, 11684157899954979996979082866262653803586498995495766081693122889492206114926204346355410010887353071582115230205128010020201869047949018633033315023637473)\n\n\nThis attack has another enhances methods, that requires understanding of more mathematics about smooth numbers and sieve, so that I will only leave the address here:\nChapter 3.6 - 3.7, An Introduction to Mathematical Cryptography (J. Hoffstein, J. Pipher, J. H. Silverman)"
  },
  {
    "objectID": "RSA_Factorization.html#pollards-p-1-algorithm",
    "href": "RSA_Factorization.html#pollards-p-1-algorithm",
    "title": "12¬† Factorization Attack",
    "section": "12.3 Pollard‚Äôs p-1 Algorithm",
    "text": "12.3 Pollard‚Äôs p-1 Algorithm\nWe have \\(N = pq\\). If we can find a number \\(L\\) satisfies: \\(p - 1 | L\\) and \\(q - 1 \\nmid L\\).\nIn that case, we can rewrite \\(L\\) as:\n\\[\n\\displaylines{L = i(p-1) \\qquad and  \\qquad L = j(q-1) + k}\n\\]\nChoose a number \\(a\\), which has a huge probability that \\(GCD(a, n) = 1\\). From Fermat‚Äôs Little Theorem:\n\\[\n\\displaylines{a^{L} \\equiv a^{i(p-1)} \\equiv 1 \\pmod p \\\\ a^{L} \\equiv a^{j(q-1) + k} \\equiv a^k \\pmod q}\n\\]\nThen, it means \\(p | a^L - 1\\), and \\(q \\nmid a^L - 1\\), for a huge probability. Then, we can find \\(p\\) easily by computing:\n\\[\np = GCD(a^L - 1, N)\n\\]\nTo build the number \\(L\\), if the number \\(p-1\\) has several small prime factors, then it may included in the factorial of \\(n!\\), for \\(n\\) is big enough.\nThe Pollard‚Äôs \\(p-1\\) algorithm is built on this idea. At each step, we will try to find the \\(GCD(a^{n!}, N)\\), and increase to \\(n+1\\). It is remarkable that, the exponent modulo is easier to compute rather than original modulo.\ndef PollardP_1(N, B=0):\n    '''\n        Find factoring of a semiprime n = pq, where at least p-1 or q-1 has some small prime factors.\n    '''\n    # If the bound is not applied, \n    if not B: B = ceil(sqrt(N))\n    # try each a \n    a = Integers(N).random_element()\n    b = a\n\n    for ell in primes(B):\n        q = 1\n        while q < N: \n            q *= ell \n        b = b^q     # computing the exponent with factorial modulo\n        if b == 1:  \n            return 0\n        d = gcd(b.lift()-1, N) # lift() function to make they in the same group for GCD. \n        if d > 1: \n            return d \n    return 0\nn = 10028219737\np = PollardP_1(n)\nassert n % p == 0\nprint(p, n // p)\n\n\n100153 100129"
  },
  {
    "objectID": "RSA_Parameters.html",
    "href": "RSA_Parameters.html",
    "title": "13¬† Bad choices of parameters",
    "section": "",
    "text": "The bad choice of parameters in RSA can come in many variants: low public, low private, etc. and also in the implementations of the RSA and also the prime generator.\n\n14 Low public exponent\nA popular choice of \\(e\\) is \\(3\\), as it will reduce the time to encrypt. However, with a big choice of public exponent, this may make the ciphertext in danger, as \\(3\\) times of exponent may do not change the value under the modulo. The root can be computed quickly, via the library gmpy2 of Python.\nfrom gmpy2 import iroot\nfrom Crypto.Util.number import *\np, q = getPrime(512), getPrime(512)\nn = p*q \nphiN = (p - 1)*(q - 1)\ne = 3\nd = inverse(e, n)\nm = getRandomNBitInteger(256)\nc = pow(m, e, n)\nm_break = iroot(int(c), int(e))\nprint(m_break)\nassert m_break[0] == m \nprint(m)\n\n\n(mpz(66318096938064539812055470481101268837694168391016765092562961494909009680309), True)\n66318096938064539812055470481101268837694168391016765092562961494909009680309"
  },
  {
    "objectID": "RSA_Parameters.html#low-public-exponent",
    "href": "RSA_Parameters.html#low-public-exponent",
    "title": "13¬† Bad choices of parameters & Side-channel",
    "section": "13.2 Low public exponent",
    "text": "13.2 Low public exponent\nA popular choice of \\(e\\) is \\(3\\), as it will reduce the time to encrypt. However, with a big choice of public exponent, this may make the ciphertext in danger, as \\(3\\) times of exponent may do not change the value under the modulo. The root can be computed quickly, via the library gmpy2 of Python.\nfrom gmpy2 import iroot\nfrom Crypto.Util.number import *\np, q = getPrime(512), getPrime(512)\nn = p*q \nphiN = (p - 1)*(q - 1)\ne = 3\nd = inverse(e, n)\nm = getRandomNBitInteger(256)\nc = pow(m, e, n)\nm_break = iroot(int(c), int(e))\nprint(m_break)\nassert m_break[0] == m \nprint(m)\n\n\n(mpz(85466728970802496052231641309227590688461946610431708918707661868612928527412), True)\n85466728970802496052231641309227590688461946610431708918707661868612928527412"
  },
  {
    "objectID": "RSA_Parameters.html#low-private-exponent",
    "href": "RSA_Parameters.html#low-private-exponent",
    "title": "13¬† Bad choices of parameters & Side-channel",
    "section": "13.3 Low private exponent",
    "text": "13.3 Low private exponent\nIn another way, a small choice of private exponent (can be created by a too huge public exponent), also can leak the ciphertext. In here, we will look at the Wiener‚Äôs attack.\nAs we know, the \\(ed \\equiv 1 \\pmod{\\phi(n)}\\), in another words, \\(ed - k\\phi(n) = 1\\). Divide both side with \\(d\\phi(n)\\):\n\\[\n\\bigg | \\frac{e}{\\phi(n)} - \\frac{k}{d} \\bigg | = \\frac{1}{d\\phi(n)}\n\\]\nWith a huge \\(d\\phi(n)\\), we will have a negligible \\(\\frac{1}{d\\phi(n)}\\). Therefore, \\(\\frac{e}{\\phi(n)}\\) could be used as an approximation of \\(\\frac{k}{d}\\), or vice versa. Although we know \\(e\\), we don‚Äôt know \\(\\phi(n)\\).\nHowever, there is a theorem, from M. Wiener, that can help us a little bit:\n\n\n\n\n\n\nWiener‚Äôs theorem\n\n\n\nLet \\(n = pq\\) \\((q \\lt p \\lt 2q)\\), If the private exponent \\(d < \\frac{1}{3}N^{1/4}\\), then an advisery can recover \\(d\\).\n\n\nThe proof can be found in Wikipedia page of Wiener‚Äôs theorem.\nThe core of the algorithm is that, we can use \\(n\\) as \\(\\phi(n)\\) in the context of Wiener‚Äôs attack. Then, as we has stated \\(\\frac{e}{\\phi(n)}\\) could be used as an approximation of \\(\\frac{k}{d}\\), then either \\(\\frac{e}{n}\\) (in the context of this attack). We use a method of Continued Fraction on \\(\\frac{e}{n}\\), then consequently find convergents of its and check if we can find the right \\(\\frac{k}{d}\\). Once we know this, we could find back \\(d\\) via an quadratic equation. Consequently, we could find back the factorization of \\(n\\).\ndef wiener(n, e, c):\n    '''\n    Solve for d in c = m^e mod n using the Wiener attack.\n    '''\n    # Calculate continued fraction expansion of e/n\n    frac = continued_fraction(e / n)\n    convergents = [[x.numerator(), x.denominator()] for x in frac.convergents()]\n    # Iterate over convergents\n    for (k, d) in convergents:\n        # Check if d is actually an integer\n        if k == 0 or d%2 == 0 or e*d % k != 1:\n            continue\n        phi = (e*d - 1)/k\n        # Create the polynomial\n        x = PolynomialRing(RationalField(), 'x').gen()\n        f = x^2 - (n-phi+1)*x + n\n        roots = f.roots()\n        # Check if polynomial as two roots\n        if len(roots) != 2:\n            continue\n        # Check if roots of the polynomial are p and q\n        p,q = int(roots[0][0]), int(roots[1][0])\n        if p*q == n:\n            return d, k\n    # No solution found\n    return None\n\nn = 6727075990400738687345725133831068548505159909089226909308151105405617384093373931141833301653602476784414065504536979164089581789354173719785815972324079\ne = 4805054278857670490961232238450763248932257077920876363791536503861155274352289134505009741863918247921515546177391127175463544741368225721957798416107743\nc = 5928120944877154092488159606792758283490469364444892167942345801713373962617628757053412232636219967675256510422984948872954949616521392542703915478027634\nd, k = wiener(n, e, c)\nphiN = (e*d - 1) // k\nprint(phiN)\n# solve for the prime factorization \nx = var('x')\nf = n - n/x - x + 1 - phiN\np, q = [x[0] for x in f.roots()]\nassert p*q == n\nprint(f\"n = {p}*{q}\")\n\n\n6727075990400738687345725133831068548505159909089226909308151105405617384093204788307013638609485547090121764648347578045648962637915516010740917782550840\n\n\nn = 63949859459297920725542167940404754256294386312715512490347273751054137071981*105192975360365123391387526351896101933106732127903638948310435293844052701259"
  },
  {
    "objectID": "RSA_Parameters.html#hastads-broadcast-attack",
    "href": "RSA_Parameters.html#hastads-broadcast-attack",
    "title": "13¬† Bad choices of parameters & Side-channel",
    "section": "13.4 Hastad‚Äôs Broadcast Attack",
    "text": "13.4 Hastad‚Äôs Broadcast Attack\nIf someone send same message over and over again, without any padding; someone could read the messages, from the Hastad‚Äôs Broadcast Attack.\nAssume that the adversary collected \\(i\\) ciphertexts (\\(i \\gt e\\)), then we can have a system of modular equation:\n\\[\n\\left\\{\\begin{matrix}\nc_1 &\\equiv m^e \\pmod{n_1} \\\\\nc_2 &\\equiv m^e \\pmod{n_2} \\\\\n...\\\\\nc_i &\\equiv m^e \\pmod{n_i}\n\\end{matrix}\\right.\n\\]\nFrom Chinese Remainder Theorem, we could find a number \\(C \\equiv m^e \\pmod{\\Pi_{j=1}^i n_j}\\). As the multiplication of \\(n_i\\) is really big, we can sure that taking \\(e^{th}\\)-root of \\(m^e\\) could help us get the ciphertext.\n# Implementation of Hastad's Broadcast attack, normal version\ndef Hastad(ciphertext, n):\n    x = crt(ciphertext, n)\n    return real_nth_root(x, e)\n\nn1 = 15531155256715702473857617704486808708718149144340218293989572553\nn2 = 4665876664449238167503227140673941051177208287344383452644505383\nn3 = 21183715744016961916768204882841616031088804561756503460509763179\ne = 3\nm = 23333333333333333333333333333333333333333333\nc1 = 3545246357420027751080801513596354805792507454079198980994208613\nc2 = 2707010410568402623621857261477803260225040847370109587024036966\nc3 = 9988366267699268191504634643058847989157961583452909799090445547\n\nn = [n1, n2, n3]\nc = [c1, c2, c3]\nmessage = Hastad(c, n)\nassert pow(message, e, n1) == c1\nprint(message)\n\n\n23333333333333333333333333333333333333333333\n\n\nWith some more sophisticated padding (but fixed), the attack still can be applied via the Coppersmith‚Äôs method. The clearer explaination could be found via Wikipedia page of this attack."
  },
  {
    "objectID": "RSA_Parameters.html#common-modulus",
    "href": "RSA_Parameters.html#common-modulus",
    "title": "13¬† Bad choices of parameters & Side-channel",
    "section": "13.1 Common modulus",
    "text": "13.1 Common modulus\nIf lucky enough, we capture two messages with two semiprimes \\(n_1\\) and \\(n_2\\) that share a same prime factor, indeed we can find the prime factorization of both, via finding \\(GCD(n_1, n_2)\\).\nAlthough this attack seems impractical, a research paper has found out that about 3-5% of public key on the Internet (that they can find out), share the prime factorization. With the method of rainbow attack which has been introduced in the previous chapter, many more could be broken."
  },
  {
    "objectID": "RSA_Parameters.html#side-channel-attack-example",
    "href": "RSA_Parameters.html#side-channel-attack-example",
    "title": "13¬† Bad choices of parameters & Side-channel",
    "section": "13.5 Side-channel attack example",
    "text": "13.5 Side-channel attack example\nThe side-channel attack is a big class of attack, so in here we just have a look at a small mechanism of it: the square-and-multiply algorithm. Most of modular arithmetic implementation for exponentation is something like this:\ndef exponent(a, b, n): \n    '''\n        Computing a^b mod n\n    '''\n    res = 1\n    while (b > 0):\n        if (b % 2 == 1):\n            res = ((res % n) * (a % n)) % n \n        a = ((res % n) * (res % n)) % n\n        b //= 2\n    return res \nAs you may notice, if the current bit of \\(b\\) in the above process is 1, it will execute the multiplication twice, rather than in case the bit is 0. With big number of RSA, this could require a noticeable amount of time.\nTherefore, if someone can attach the power clock on the decryption device; and looking for the pattern of ‚Äòdecryption‚Äô:\n\nThen, this could reveal the bit of \\(d\\)."
  },
  {
    "objectID": "RSA_Parameters.html#a-very-quick-introduction-to-coppersmiths-method",
    "href": "RSA_Parameters.html#a-very-quick-introduction-to-coppersmiths-method",
    "title": "13¬† Bad choices of parameters & Side-channel",
    "section": "13.6 A very quick introduction to Coppersmith‚Äôs method",
    "text": "13.6 A very quick introduction to Coppersmith‚Äôs method\nDon Coppersmith, a mathematician, has introduced a method of solving modular polynomials in polynomial time. Basically, his method will convert the modular polynomials under a modulo to a normal polynomial in \\(\\mathbb{Z}\\), then we can apply the numerical analysis method on the new polynomial. This conversion is supported by an algorithm called LLL lattice basis reduction\nTo provide a quick example, we will examine if a RSA process using a fixed padding scheme.\nAssume we have two guys is sharing their AES-256 key. As they know RSA without padding is vulnerable, they used this padding scheme:\n\\[\nm = 2^{1024} - 2^{128} + k\n\\]\nFor \\(k\\) is their key. \\(m\\) is the padded-key.\nTherefore, the ciphertext will be sent can be written as:\n\\[\nc \\equiv (2^{1024} - 2^{128} + k)^e \\pmod n\n\\]\nThen, we could have a polynomial \\(f(x) = (2^{1024} - 2^{128} + k)^e - c = 0\\) under the \\(\\mathbb{Z}_n\\).\nWith the Coppersmith‚Äôs method, we can solve this polynomial for \\(k\\):\nfrom Crypto.Util.number import *\n\ne = 3\np, q = getPrime(512), getPrime(512)\nn = p*q \nkey = getRandomNBitInteger(128)\n# print(key)\nm = 2**1024 - 2**128 + key\nc = pow(m, e, n)\nprint(c)\n\nK = Zmod(n)\nP.<x> = PolynomialRing(K, implementation = 'NTL')\nf = (2^1024 - 2^128 + x)^e - c \nkeyBroken = f.small_roots()[0]\nassert keyBroken == key\nprint(keyBroken)\n\n\n82633033845796004747549573332791642419336976223134503191365351063499016327870528606411650067623106729110435236002973001108860823873209355855425694267378772683429911986067425672621927056108387620153618400631818657150449693722782685126044287318464943689078280311043761541667438647198552521827816508055402758969\n\n\n\n\n\n286929976551044907179886525566763542034\n\n\nThe Coppersmith‚Äôs method is applied in a very wide range of attacks if there is a fixed relationship between the components of RSA. A very noticable case is the ROCA attack, that have leaked more than hundred thousands of ID cards in Estonian."
  },
  {
    "objectID": "RSA_Parameters.html#conclusion",
    "href": "RSA_Parameters.html#conclusion",
    "title": "13¬† Bad choices of parameters & Side-channel",
    "section": "13.7 Conclusion",
    "text": "13.7 Conclusion\nRSA attacks is in a wide range, and different methods that this document can not cover it all. For a general knowledge of RSA, I recommend you to spend time on this paper of professor Dan Boneh: Twenty years of Attacks on RSA Cryptosystem. Also, there are some compiled version of many RSA attacks on GitHub, like this one: [RsaCtfTool][(https://github.com/RsaCtfTool/RsaCtfTool)."
  },
  {
    "objectID": "DiffieHellman.html",
    "href": "DiffieHellman.html",
    "title": "14¬† Diffie-Hellman Key Exchange",
    "section": "",
    "text": "The motivation for a key exchange scheme could be sharing the same key over a insecure environment, to let both two parties have a same value to put their symmetric encryption on. Diffie-Hellman is one of the best (also the first) key exchange scheme could do well in this purpose, in both sense of security and application."
  },
  {
    "objectID": "DiffieHellman.html#diffie-hellman-basic",
    "href": "DiffieHellman.html#diffie-hellman-basic",
    "title": "14¬† Diffie-Hellman Key Exchange",
    "section": "14.1 Diffie-Hellman basic",
    "text": "14.1 Diffie-Hellman basic\nAssuming that Alice and Bob want to have a same key for their AES encryption over the conversation.\n\nFirst, Alice (or Bob) will establish two numbers: a big prime \\(p\\) and its generator \\(g\\).\nNext, Alice will choose a number \\(a \\in \\mathbb{Z}_p\\), which will act as her private key, while Bob also choose a number \\(b \\in \\mathbb{Z}_p\\).\nThen, both parties will compute their public number:\n\n\\[\n\\displaylines{A \\equiv g^a \\pmod p \\\\ B \\equiv g^b \\pmod p}\n\\]\nThen, Alice and Bob will send \\(A, B\\) to the other. Remember, other adversary can know this value too.\n\nWhen having \\(B, A\\), respectively, Alice and Bob is ready to have their common secret.\n\nFrom Alice‚Äôs side: \\[\nS \\equiv B^a \\equiv (g^b)^a \\equiv g^{ba} \\pmod p  \n\\]\nIn the same way, Bob will find \\(A^b\\). This two number is indeedly the same. Then, they have successfully find their common secret.\nThe security of Diffie-Hellman lies in the hard problem of discrete logarithm. For the adversary, with a good choice of \\(p\\), they cannot find the private key of Alice & Bob (i. e. finding either \\(log_g(A) \\pmod p\\) and \\(log_g(B) \\pmod p\\). In the same sense, this hardness is applied on Alice and Bob if they want to know the other‚Äôs secret."
  },
  {
    "objectID": "DiffieHellman.html#cryptosystem-built-on-discrete-logarithm",
    "href": "DiffieHellman.html#cryptosystem-built-on-discrete-logarithm",
    "title": "14¬† Diffie-Hellman Key Exchange",
    "section": "14.2 Cryptosystem built on Discrete Logarithm",
    "text": "14.2 Cryptosystem built on Discrete Logarithm\nThere are some others cryptosystem (like RSA), that built on the Discrete Logarithm rather than the trapdoor function of factorization. One significant is ElGamal."
  },
  {
    "objectID": "Attacks_DH.html",
    "href": "Attacks_DH.html",
    "title": "15¬† Some attacks on Diffie-Hellman",
    "section": "",
    "text": "In this chapter, we will cover the methods of breaking the Discrete Logarithm - the core of Diffie-Hellman."
  },
  {
    "objectID": "Attacks_DH.html#baby-step-giant-step-algorithm",
    "href": "Attacks_DH.html#baby-step-giant-step-algorithm",
    "title": "15¬† Some attacks on Diffie-Hellman",
    "section": "15.1 Baby step, giant step algorithm",
    "text": "15.1 Baby step, giant step algorithm"
  },
  {
    "objectID": "Attacks_DH.html#baby-step-giant-step",
    "href": "Attacks_DH.html#baby-step-giant-step",
    "title": "15¬† Some attacks on Diffie-Hellman",
    "section": "15.1 Baby step, giant step",
    "text": "15.1 Baby step, giant step\nThis algorithm would be able to break the Discrete Logarithm in the complexity \\(O(\\sqrt{n})\\), for \\(n\\) is the bit-size of \\(x\\).\nLet‚Äôs give \\(x\\) a bound, \\(0 \\lt x \\le 2^{40}\\).\nLet \\(B = 2^{20}\\). \\(x < B^2\\), then we can write down \\(x\\) as:\n\\[\nx = x_0\\cdot B + x_1\n\\]\nwhere \\(x_0, x_1 \\in [0, B-1]\\)\n\\[\nh \\equiv g^x \\equiv g^{x_0B+x_1} \\equiv (g^B)^{x_0} \\cdot g^{x_1} \\pmod p\n\\]\nThen, if we divide both side with \\(g^{x_1}\\):\n\\[\n\\frac{h}{g^{x_1}} \\equiv (g^B)^{x_0} \\pmod p$\n\\]\nFrom here, we can find the logarithm by building the hash table of every value \\(\\frac{h}{g^x_1}\\); then, finding if we have a collision of \\((g^B)^{x_0}\\) for both \\(x_0, x_1 \\in \\mathbb{Z}_p\\)\nIf we have found such a pair \\(x_0, x_1\\), we can compute back \\(x = x_0B + x_1\\).\nfrom math import ceil, sqrt\n\n\ndef bsgs(g, h, p):\n    '''\n    Solve for x in h = g^x mod p given a prime p.\n    If p is not prime, you shouldn't use BSGS anyway.\n    '''\n    N = ceil(sqrt(p - 1))  # phi(p) is p-1 if p is prime\n    # Store hashmap of g^{1...m} (mod p). Baby step.\n    tbl = {pow(g, i, p): i for i in range(N)}\n    # Precompute via Fermat's Little Theorem\n    c = pow(g, N * (p - 2), p)\n    # Search for an equivalence in the table. Giant step.\n    for j in range(N):\n        y = (h * pow(c, j, p)) % p\n        if y in tbl:\n            return j * N + tbl[y]\n    # Solution not found\n    return None\n\nprint(bsgs(7894352216, 355407489, 604604729))\n\n\n102900819"
  },
  {
    "objectID": "Attacks_DH.html#pohlig-hellman-algorithm",
    "href": "Attacks_DH.html#pohlig-hellman-algorithm",
    "title": "15¬† Some attacks on Diffie-Hellman",
    "section": "15.2 Pohlig-Hellman Algorithm",
    "text": "15.2 Pohlig-Hellman Algorithm\n\n15.2.1 Smooth number\nSmooth prime could be informally interpreted as having its order (i. e. \\(p-1\\)) to have many small primes in their factorization. More specifically, a number is \\(B\\)-smooth if it has its primes to be smaller or equal than \\(B\\).\n\nFor example, prime \\(101\\) is \\(5\\)-smooth, as its order \\(100 = 2^2 \\cdot 5^5\\)\n\n\n\n15.2.2 Pohlig-Hellman\nRecall, in the discrete logarithm problem, \\(g^x \\equiv h \\pmod p\\), \\(p\\) is prime; which we cannot apply some algorithms like Chinese Remainder Theorem on \\(p\\) directly. However, The solution of \\(x\\) only live in \\(\\mathbb{Z}_{p-1}\\) (Can be explained by Fermat‚Äôs Little Theorem), which hints us about the using of factorization of \\(p-1\\) may help in this case.\nThe Pohlig-Hellman Algorithm exploit this fact, and also with the support of Lagrange‚Äôs Theorem. The process of the algorithm could be shortly written as:\n\n\n\n\n\n\nPohlig-Hellman Algorithm\n\n\n\nAssume the prime \\(p\\) has its order \\(N = q_1^{e_1} \\cdot q_2^{e_2} \\ldots q_t^{e_t}\\)\n\nStep 1: for each \\(1 \\le i \\le t\\), let: \\[\n\\displaylines{g_i \\equiv g^{N/q_i^{e_i}} \\qquad h_i \\equiv h^{N/q_i^{e_i}} \\pmod N}\n\\]\n\nThen, according to the Lagrange‚Äôs Theorem, \\(g_i\\) has prime order \\(q_i^{e_i}\\). Therefore, we can solve this problem:\n\\[\ng_i^y \\equiv h_i \\pmod{q_i^{e_i}}\n\\]\nUsing the ‚ÄúBaby step, giant step‚Äù is a choice.\n\nStep 2: Then, we can apply CRT on:\n\n\\[\n\\left\\{\\begin{matrix}\nx &\\equiv y_1 \\pmod{q_1^{e_1}} \\\\\nx &\\equiv y_2 \\pmod{q_2^{e_2}} \\\\\n...\\\\\nx &\\equiv y_t \\pmod{q_t^{e_t}}\n\\end{matrix}\\right.\n\\]\nAfter that, we could find a number \\(x\\) holds the original discrete logarithm problem.\n\n\nFor a quick sketch of proof, you can visit the chapter 2.9 of the book An Introduction to Mathematical Cryptography, that has been introduced before in the document. In general, here is the process of Pohlig-Hellman Algorithm:\n\ndef PohligHellman(g, h, p):\n    '''\n    Solve for x where g^x = h mod p\n    '''\n    factorList = list(factor(p-1))\n    X = [] \n    a = []\n    for q, e in factorList: \n        a.append(q^e)\n        # print(q, e)\n        A = g^((p-1)/(q^e)) % p\n        B = h^((p-1)/(q^e)) % p\n        xg = xgcd(A, p) # Extended Euclidean Algorithm\n        A_inv = (xg[1] % p + p) % p\n        # print(A, B)\n        x = []\n        lhs = A^(q^(e - 1)) % p \n        rhs = B^(q^(e - 1)) % p\n        for x0 in range(p):\n            if (pow(lhs, x0, p) == rhs % p):\n                x.append(x0)\n                break \n        for i in reversed(range(e - 1)):\n            degree = sum([x_i*q^j for x_i, j in zip(x, range(e - i))])\n            rhs = (B * (A_inv^degree % p))^(q^i) % p\n            for xi in range(p):\n                if (pow(lhs, xi, p) == rhs % p):\n                    x.append(xi)\n                    break\n        # print(x)\n        X.append(sum([x_i*q^j for x_i, j in zip(x, range(e))]))\n    # print(X, a)\n    x_sol = crt(X, a)\n    assert pow(g, x_sol, p) == h\n    return x_sol\n\ndef test():\n    g = 7\n    p = 433\n    h = 166\n    x_1 = PohligHellman(g, h, p)\n    assert pow(g, x_1, p) == h \n\ntest()\n\n\n47"
  },
  {
    "objectID": "BreakingDLP.html#baby-step-giant-step",
    "href": "BreakingDLP.html#baby-step-giant-step",
    "title": "15¬† Breaking DLP",
    "section": "15.1 Baby step, giant step",
    "text": "15.1 Baby step, giant step\nThis algorithm would be able to break the Discrete Logarithm in the complexity \\(O(\\sqrt{n})\\), for \\(n\\) is the bit-size of \\(x\\).\nLet‚Äôs give \\(x\\) a bound, \\(0 \\lt x \\le 2^{40}\\).\nLet \\(B = 2^{20}\\). \\(x < B^2\\), then we can write down \\(x\\) as:\n\\[\nx = x_0\\cdot B + x_1\n\\]\nwhere \\(x_0, x_1 \\in [0, B-1]\\)\n\\[\nh \\equiv g^x \\equiv g^{x_0B+x_1} \\equiv (g^B)^{x_0} \\cdot g^{x_1} \\pmod p\n\\]\nThen, if we divide both side with \\(g^{x_1}\\):\n\\[\n\\frac{h}{g^{x_1}} \\equiv (g^B)^{x_0} \\pmod p$\n\\]\nFrom here, we can find the logarithm by building the hash table of every value \\(\\frac{h}{g^x_1}\\); then, finding if we have a collision of \\((g^B)^{x_0}\\) for both \\(x_0, x_1 \\in \\mathbb{Z}_p\\)\nIf we have found such a pair \\(x_0, x_1\\), we can compute back \\(x = x_0B + x_1\\).\nfrom math import ceil, sqrt\n\n\ndef bsgs(g, h, p):\n    '''\n    Solve for x in h = g^x mod p given a prime p.\n    If p is not prime, you shouldn't use BSGS anyway.\n    '''\n    N = ceil(sqrt(p - 1))  # phi(p) is p-1 if p is prime\n    # Store hashmap of g^{1...m} (mod p). Baby step.\n    tbl = {pow(g, i, p): i for i in range(N)}\n    # Precompute via Fermat's Little Theorem\n    c = pow(g, N * (p - 2), p)\n    # Search for an equivalence in the table. Giant step.\n    for j in range(N):\n        y = (h * pow(c, j, p)) % p\n        if y in tbl:\n            return j * N + tbl[y]\n    # Solution not found\n    return None\n\nprint(bsgs(7894352216, 355407489, 604604729))\n\n\n102900819"
  },
  {
    "objectID": "BreakingDLP.html#pohlig-hellman-algorithm",
    "href": "BreakingDLP.html#pohlig-hellman-algorithm",
    "title": "15¬† Breaking DLP",
    "section": "15.2 Pohlig-Hellman Algorithm",
    "text": "15.2 Pohlig-Hellman Algorithm\n\n15.2.1 Smooth number\nSmooth prime could be informally interpreted as having its order (i. e. \\(p-1\\)) to have many small primes in their factorization. More specifically, a number is \\(B\\)-smooth if it has its primes to be smaller or equal than \\(B\\).\n\nFor example, prime \\(101\\) is \\(5\\)-smooth, as its order \\(100 = 2^2 \\cdot 5^5\\)\n\n\n\n15.2.2 Pohlig-Hellman\nRecall, in the discrete logarithm problem, \\(g^x \\equiv h \\pmod p\\), \\(p\\) is prime; which we cannot apply some algorithms like Chinese Remainder Theorem on \\(p\\) directly. However, The solution of \\(x\\) only live in \\(\\mathbb{Z}_{p-1}\\) (Can be explained by Fermat‚Äôs Little Theorem), which hints us about the using of factorization of \\(p-1\\) may help in this case.\nThe Pohlig-Hellman Algorithm exploit this fact, and also with the support of Lagrange‚Äôs Theorem. The process of the algorithm could be shortly written as:\n\n\n\n\n\n\nPohlig-Hellman Algorithm\n\n\n\nAssume the prime \\(p\\) has its order \\(N = q_1^{e_1} \\cdot q_2^{e_2} \\ldots q_t^{e_t}\\)\n\nStep 1: for each \\(1 \\le i \\le t\\), let: \\[\n\\displaylines{g_i \\equiv g^{N/q_i^{e_i}} \\qquad h_i \\equiv h^{N/q_i^{e_i}} \\pmod N}\n\\]\n\nThen, according to the Lagrange‚Äôs Theorem, \\(g_i\\) has prime order \\(q_i^{e_i}\\). Therefore, we can solve this problem:\n\\[\ng_i^y \\equiv h_i \\pmod{q_i^{e_i}}\n\\]\nUsing the ‚ÄúBaby step, giant step‚Äù is a choice.\n\nStep 2: Then, we can apply CRT on:\n\n\\[\n\\left\\{\\begin{matrix}\nx &\\equiv y_1 \\pmod{q_1^{e_1}} \\\\\nx &\\equiv y_2 \\pmod{q_2^{e_2}} \\\\\n...\\\\\nx &\\equiv y_t \\pmod{q_t^{e_t}}\n\\end{matrix}\\right.\n\\]\nAfter that, we could find a number \\(x\\) holds the original discrete logarithm problem.\n\n\nFor a quick sketch of proof, you can visit the chapter 2.9 of the book An Introduction to Mathematical Cryptography, that has been introduced before in the document. In general, here is the process of Pohlig-Hellman Algorithm:\n\ndef PohligHellman(g, h, p):\n    '''\n    Solve for x where g^x = h mod p\n    '''\n    factorList = list(factor(p-1))\n    X = [] \n    a = []\n    for q, e in factorList: \n        a.append(q^e)\n        # print(q, e)\n        A = g^((p-1)/(q^e)) % p\n        B = h^((p-1)/(q^e)) % p\n        xg = xgcd(A, p) # Extended Euclidean Algorithm\n        A_inv = (xg[1] % p + p) % p\n        # print(A, B)\n        x = []\n        lhs = A^(q^(e - 1)) % p \n        rhs = B^(q^(e - 1)) % p\n        for x0 in range(p):\n            if (pow(lhs, x0, p) == rhs % p):\n                x.append(x0)\n                break \n        for i in reversed(range(e - 1)):\n            degree = sum([x_i*q^j for x_i, j in zip(x, range(e - i))])\n            rhs = (B * (A_inv^degree % p))^(q^i) % p\n            for xi in range(p):\n                if (pow(lhs, xi, p) == rhs % p):\n                    x.append(xi)\n                    break\n        # print(x)\n        X.append(sum([x_i*q^j for x_i, j in zip(x, range(e))]))\n    # print(X, a)\n    x_sol = crt(X, a)\n    assert pow(g, x_sol, p) == h\n    return x_sol\n\ndef test():\n    g = 7\n    p = 433\n    h = 166\n    x_1 = PohligHellman(g, h, p)\n    assert pow(g, x_1, p) == h \n\ntest()\n\n\n47"
  },
  {
    "objectID": "DiffieHellman.html#meet-in-the-middle",
    "href": "DiffieHellman.html#meet-in-the-middle",
    "title": "14¬† Diffie-Hellman Key Exchange",
    "section": "14.3 Meet-in-the-middle",
    "text": "14.3 Meet-in-the-middle\nNow, we will discuss about an attack in Diffie-Hellman Key Exchange.\nLet Mallory be the adversary, by some ways can interrupt and intimate the sharing scheme between Alice and Bob.\n\nMallory will send his private key to Bob and Alice. And by this mean, the shared secret that Alice and Bob would compute is \\(g^{az}\\) and \\(g^{bz}\\), which Mallory also has.\nThen, Mallory would establish two secret connections between Alice and Bob, using these two shared secrets, and can read the plaintext between Alice and Bob.\nHowever, Mallory still cannot find back Alice and Bob secret key \\(a, b\\). We will discuss this on the next chapter."
  },
  {
    "objectID": "BreakingDLP.html#small-subgroup-confinement",
    "href": "BreakingDLP.html#small-subgroup-confinement",
    "title": "15¬† Breaking DLP",
    "section": "15.3 Small subgroup confinement",
    "text": "15.3 Small subgroup confinement\nIn the real cases, the prime would be used as the safe primes, which have the property that \\(\\frac{(p - 1)}{2}\\) is also a prime. By this, there will be no small primes in factorization of \\(p - 1\\).\nHowever, if by some ways, Bob do not change his private key with other conversation, he will be broken by an attack called Small Subgroup Confinement. The mechanism of this attack is that, by choosing a prime \\(p'\\) that is both: 1. larger than original, 2. smooth, the attacker will fool Bob to use his \\(p'\\) and then can indeedly solve the Discrete Logaritm on the prime \\(p'\\) rather than \\(p\\).\nThis is an example of Subgroup attack.\nfrom Crypto.Util.number import *\n\ndef safePrime(n):\n    while True: \n        p = getPrime(n)\n        if isPrime((p-1)//2):\n            return p\n\np = safePrime(512)\ng = 2\nx = getRandomRange(1, p-1)\nh = pow(g, x, p)\nprint(g, h, p)\n\n# Assuming we can ask Bob to calculate the exchange...\np_smooth = 11520796732441878515027373358328216938283048199188491628006176039599126895829173510147739451884815667612904500823587381619486714035051906673720821163556657311958585660374139051567952188324884102442385219224493620823660444932593986100650360037352878445543646628098538099116078184566756291092367196511240004251792982479476655806091759279086274692942838381048910186636592077380073350162280464968139585924763388159814562289552926323602180142347053299426189205228246387\nn_smooth = p_smooth - 1\nh_smooth = pow(g, x, p_smooth)\nx_smooth = PohligHellman_ShortCut(g, h_smooth, p_smooth)\nprint(x_smooth)\nprint(x)\n\n\n2 23232627927715145862685568329338188710053174168696097126470764275177850578641808809764860546412414219169515413665161651427185191260099570603582784449388 7749379998087896010968255093389721753219171862563309076487333981874026588517919029368648430973371905392515879043689033427998776100901605515584491998175843\n\n\n1412604233344152118025291155071554767608593025971192643130660902487192186944600281627338500606062424801009475967786332663459600515187487467642223244937262\n1412604233344152118025291155071554767608593025971192643130660902487192186944600281627338500606062424801009475967786332663459600515187487467642223244937262"
  },
  {
    "objectID": "Elliptic_Curve.html#elliptic-curve",
    "href": "Elliptic_Curve.html#elliptic-curve",
    "title": "16¬† Introduction to Elliptic Curve",
    "section": "16.1 Elliptic Curve",
    "text": "16.1 Elliptic Curve\nAn elliptic curve is the set of solutions to an equation of the form:\n\\[\nY^2 = X^3 + AX + B\n\\]\nfor A, B as the parameters. The constraints over \\(A, B\\) is:\n\\[\n\\Delta_E = 4A^3 + 27B^2 \\neq 0\n\\]\nFor example, here is the elliptic curve \\(Y^2 = X^3 - 3X + 3\\)\nE = EllipticCurve([-3, 3]) # create curve y^2 = x^3 - 3x + 3\nE.plot()\nE = EllipticCurve([-3, 3])\nE.plot()\nThe basic operation on Elliptic Curve is addition.\n\n16.1.1 Addition rules\nIf two points are different (i. e. \\(P\\) + \\(Q\\)):\n\nConnect \\(P, Q\\) as a line \\(L\\), with intersection \\(R\\).\nTake reflection of \\(R\\) over x-axis \\(\\rightarrow R'\\).\n\n\n\nThis operation is easy, as \\[\nY = \\lambda \\cdot (X-x_1) + y_1\n\\] where the slope \\(\\lambda = \\frac{y_2-y_1}{x_2-x_1}\\)\nSubstitute \\(Y\\) as an expression of \\(X\\), we can find all values \\(X, Y\\)\n\nAddition of the same points (\\(P + P\\))\n\nFind the tangent \\(L\\) at \\(P\\) on the curve \\(E\\).\nFind its intersection on \\(E\\), and also take the reflection.\n\n\nAs \\(Y^2 = X^3 + AX + B\\), we can find the slope \\(\\frac{dY}{dX}\\) by taking its implicit derivative. \\[\n\\begin{equation}\n2Y\\cdot \\frac{dY}{dX} = 3X^2 - 15 \\qquad \\frac{dY}{dX} = \\frac{3X^2 - 15}{2Y}\n\\end{equation}\n\\] With same method as the previous case, we can find the value of \\(R'\\)\nIf the connection \\(PQ\\) is parallel with Oy\nIn the case when the connection line gives no intersection with the curve, then we define its value as null \\(\\mathcal{O}\\).\n\nWith the support of this null, we can define the addition under the curve, as in modulo arithmetic:\n\n\n\n16.1.2 Multiplication\n\nThe multiplication of point \\(P\\) on curve \\(E\\) is adding point \\(P\\) \\(n\\) times.\n\n\\[\nnP = \\underbrace{P + P + \\ldots + P}_{\\text{n times}}\n\\]\n\nIn order to generalize the addition, we have an algorithm by the way:\n\n\n\n\n\n\nWith support of SageMath, we can perform the addition and multiplication very easily.\nE = EllipticCurve([-3, 3])\n# just 2 random points\nP = E(1, 1)\nQ = E(0)\nprint(P)\nprint(Q)\nprint(P + Q)\nprint(P - Q)\nprint(P * 2)\n\n\n(1 : 1 : 1)\n(0 : 1 : 0)\n(1 : 1 : 1)\n(1 : 1 : 1)\n(-2 : -1 : 1)\n\n\nIn here, we introduced the substitution, which is just simple as \\(P - Q = P + (-Q)\\), where \\(-Q\\) can be interpreted as the reflection over \\(Ox\\) of the point.\nWith multiplication, there is also a version like square-and-multiply in modular arithmetic, which is double-and-add."
  },
  {
    "objectID": "EC_FiniteField.html",
    "href": "EC_FiniteField.html",
    "title": "17¬† Elliptic Curve over Finite Field",
    "section": "",
    "text": "In general, the elliptic curve over finite field is just a constraint over the coordinates of the points in curve to sit in a \\(\\mathbb{F}_p\\), for \\(p\\) is a prime.\nTherefore, an informal of EC over Finite Field could be like this:\n\n\n\n\n\n\nElliptic Curve over Finite Field\n\n\n\nLet \\(p \\ge 3\\) be a prime. An elliptic curve over \\(\\mathbb{F}_p\\) is an equation of the form:\n\\[\n\\displaylines{E: Y^2 = X^3 + AX + B}\n\\]\nThen, \\(E(\\mathbb{F}_p) = \\{{(x, y): x, y \\in \\mathbb{F}_p \\text{ satisfy } E} \\}\\) \\(\\cup\\) \\(\\{\\mathcal{O}\\}\\).\n\n\nFor example, we can find\n\\[\nE(\\mathbb{F}_{13}): Y^2 = X^3 + 3X + 8\n\\]\nby substituting all possible values \\(X \\in [0, 12]\\), and find the square root modulo of \\(Y^2\\).\nAfter the find, we can find the value:\n\\[\nE(\\mathbb{F_{13}}) = \\{\\mathcal{O}, (1, 5), (1, 8), (2, 3), (2, 10), (9, 6), (9, 7), (12, 2), (12, 11)\\}\n\\]\nThe Addition works exactly same as the normal case. And this will make the \\(E(\\mathbb{F_{13}})\\) a finite group."
  },
  {
    "objectID": "ECC_ECDH.html#ecdlp-elliptic-curve-discrete-logarithm-problem",
    "href": "ECC_ECDH.html#ecdlp-elliptic-curve-discrete-logarithm-problem",
    "title": "18¬† Elliptic Curve Cryptography and Elliptic Curve Diffie-Hellman",
    "section": "18.1 ECDLP (Elliptic Curve Discrete Logarithm Problem)",
    "text": "18.1 ECDLP (Elliptic Curve Discrete Logarithm Problem)\n\nIn here, we can simply define the ECDLP that \\(\\text{log}_P(Q) = n\\) when \\(nP = Q\\) in \\(E(\\mathbb{F_p})\\)\nIt turns out to be the ECDLP is also a hard problem."
  },
  {
    "objectID": "ECC_ECDH.html#ecdh",
    "href": "ECC_ECDH.html#ecdh",
    "title": "18¬† Elliptic Curve Cryptography and Elliptic Curve Diffie-Hellman",
    "section": "18.2 ECDH",
    "text": "18.2 ECDH\nAs nothing changes quite much, we can define ECDH as we have done with DH of modular arithmetic.\n\n\n\n\n\nAfter the process, Alice and Bob can use either \\(x\\) or \\(y\\) for their same secret.\nOne other notable, finding a good generator for elliptic curve is not easy. So, Alice & Bob often use pre-computed curve, generator and prime."
  },
  {
    "objectID": "RSA_Factorization.html#lenstras-elliptic-curve-factorization",
    "href": "RSA_Factorization.html#lenstras-elliptic-curve-factorization",
    "title": "12¬† Factorization Attack",
    "section": "12.4 Lenstra‚Äôs Elliptic Curve Factorization",
    "text": "12.4 Lenstra‚Äôs Elliptic Curve Factorization\nWith this method, we are using the concepts of Elliptic Curve. Therefore, you may want to look at the chapters about Elliptic Curve before coming back this chapter.\nIn the previous part, in the Pollard‚Äôs p-1 algorithm, we compute the factorial and hoping it will share the prime factorization with \\(p - 1\\). So, Can we do a ‚Äòmimic‚Äô of this, as instead of \\(a^{p-1} \\equiv 1 \\pmod p\\), we can do something like this with properties of elliptic curve on finite field addition?\n\n12.4.1 Intuition\n\nIf we know \\(P\\), we can calculate \\(2P\\), \\(3P\\), \\(\\ldots\\) easily. Let‚Äôs see with an example.\n\n\\[\nP = (38, 112) \\qquad E: Y^2 = X^3 + 3X + 7\n\\] + In here, \\(x(P), y(P)\\) mean the x and y coordinate of P\n\nFor 2P, from Addition Algorithm: \\[\n\\begin{aligned}\n\\frac{1}{2y(P)} &= \\frac{1}{224} \\equiv 91 \\pmod {187} \\\\\n\\lambda &= \\frac{3x(P)^2 + A}{2y(P)}\n\\ldots\n\\end{aligned}\n\\]\nFor 3P, from Addition Algorithm: \\[\n\\begin{aligned}\n\\frac{1}{x(2P) - x(P)} &= \\frac{1}{5} \\equiv 75 \\pmod {187} \\\\\n\\lambda &= \\frac{y(2P) - y(P)}{x(2P) - x(P)} = \\frac{14}{5} \\ldots\n\\end{aligned}\n\\]\nWe call the value \\(\\frac{1}{x} \\pmod p\\) is reciprocal.\n\nAs stated, at each step, in order to determine if we can compute the next \\((i+1)P\\), we always need to find the inverse modulo of \\(N\\) for some reciprocal value (the denominator of the \\(\\lambda\\))\nThen, the idea of Lenstra‚Äôs Factoring algorithm is just similar to Pollard \\(p-1\\): At each step, we compute \\[\nP, 2!\\cdot P, 3!\\cdot P, \\ldots\n\\]\nThere are only 3 cases for reciprocal \\(d\\):\n\nIf \\(d = kN\\), we need to change the curve and point.\nIf \\(d | N\\), we have found a prime factor!\nElse, continue our computation.\n\n\nThis algorithm works, also because of the Lagrange‚Äôs theorem.\n\nRecall, the Lagrange‚Äôs theorem stated that if a curve \\(E\\) has order \\(N\\), then any point under this curve will have the order \\(d\\) such \\(d|N\\).\nAs \\(n = pq\\), our original curve \\(E(\\mathbb{F}_n)\\) can be broken into 2 smaller curve of \\(p, q\\), each with the order \\(N_p, N_q << n\\)\nThen, for any point \\(P\\), we only need to find a number that is divisible by the order of the point \\(P\\), which also divisible by \\(N_p\\).\n\np = 6887\nE = EllipticCurve(Zmod(p), [14, 19])\nPoint = E(1512, 3166)\n\ndef pointAddition(point1, point2, p):\n    try:\n        res = point1 + point2 \n    except: \n        reciprocal = (point1[0] - point2[0]) % p \n        d = gcd(reciprocal, p)\n        return (0, 0, d)\n    return res\n\ndef multiplication(k, point, curve, p):\n    r = curve(0, 1, 0) # null \n    tmp = point \n    while k > 0:\n        if k % 2 == 1:\n            r = pointAddition(r, tmp, p)\n            if r[2] > 1:\n                return r\n        tmp = pointAddition(tmp, tmp, p)\n        k //=2 \n    return r\n\nfrom sympy.ntheory import sieve \nfrom random import randint\n\nsieve._reset()\n\ndef LenstraFactorization(n, bound):\n    sieve.extend(bound)\n    while True:\n        g = n \n        point = [0, 0]\n        a, b = 0, 0\n        while (g == n):\n            point = [randint(1, n - 1), randint(1, n - 1)]\n            a = randint(1, n - 1)\n            b = (point[1]^2 - point[0]^3 - a*point[0]) % n\n            g = gcd(4*a^3 + 27*b^2, n)\n        if g > 1:\n            return g\n        curve = EllipticCurve(Zmod(n), [a, b])\n        point = curve(point)\n        q = point\n        for p in sieve:\n            pp = p\n            while pp < bound: \n                q = multiplication(p, q, curve, n)\n                print(q)\n                if q[2] > 1:\n                    return gcd(q[2], n)\n                pp *= p\n        return False\n\nLenstraFactorization(6887, 10000)\n\n\n(545 : 5826 : 1)\n(3369 : 1745 : 1)\n(6346 : 4972 : 1)\n(1890 : 6041 : 1)\n(5382 : 2204 : 1)\n(1599 : 221 : 1)\n(5964 : 1525 : 1)\n(5091 : 2646 : 1)\n(47 : 458 : 1)\n(6158 : 1094 : 1)\n(726 : 2495 : 1)\n(6643 : 5362 : 1)\n(1114 : 3853 : 1)\n(0, 0, 97)\n\n\n97\n\n\nWith Factorization, SageMath offers a lot of methods that can be used like methods above, or Quadratic Sieve, etc. The full documentation of factorization can be found in:\n\nInteger Factorization\nFactorization\n\nFor further factoring, I recommend you to have a look at the book: The Joy of Factoring, from Samuel S. Wagstaff and some chapters in the book An Introduction to Mathematical Cryptography I mentioned above."
  },
  {
    "objectID": "ECC_ECDH.html#elliptic-curve-elgamal-cryptography",
    "href": "ECC_ECDH.html#elliptic-curve-elgamal-cryptography",
    "title": "18¬† Elliptic Curve Cryptography and Elliptic Curve Diffie-Hellman",
    "section": "18.3 Elliptic Curve ElGamal Cryptography",
    "text": "18.3 Elliptic Curve ElGamal Cryptography\nWe can build an algorithm for public key cryptography on Elliptic Curve like this:\n\nStep 1: Alice"
  },
  {
    "objectID": "ECC_ECDH.html#little-conclusion",
    "href": "ECC_ECDH.html#little-conclusion",
    "title": "18¬† Elliptic Curve Cryptography and Elliptic Curve Diffie-Hellman",
    "section": "18.3 Little conclusion",
    "text": "18.3 Little conclusion\nAlong with key sharing, Elliptic Curve can also be applied in building Public key cryptography and digital signature as RSA does.\nHowever, this is not discussed pretty much, as: + The main purposes of new cryptographic schemes are sharing rather than encrypt, as other cryptography like AES can be done pretty well the encrypt/decrypt.\n\nSeveral PKC on Elliptic Curve requires 4-to-1 (4 ciphertext to 1 plaintext), because ECC goes with points, rather than plain numbers.\n\nRight now, the theme is also shifting into Lattice-based Cryptography, which built on the problems on Matrix in Integer Field."
  },
  {
    "objectID": "ECC_Attacks.html",
    "href": "ECC_Attacks.html",
    "title": "19¬† ECDH Attacks",
    "section": "",
    "text": "In the last chapter of PKC, I will introduce to you a method"
  },
  {
    "objectID": "ECC_Attacks.html#pohlig-hellman-in-ecc",
    "href": "ECC_Attacks.html#pohlig-hellman-in-ecc",
    "title": "19¬† ECDH Attacks",
    "section": "19.1 Pohlig-Hellman in ECC",
    "text": "19.1 Pohlig-Hellman in ECC\nIn elliptic curve, we know that we need to choose a finite field \\(\\mathbb{F}_p\\). If this prime \\(p\\) is smooth, we can sure that the discrete logarithm on the curve is also vulnerable. As in Pohlig-Hellman chapter for Diffie-Hellman, the discrete logarithm on the curve could be computed on each curve with the finite field of prime factorization.\nAlso, SageMath comes with the function discrete_log() for computing this one:\ndef discreteLogarithm(p, a, b, G, B, A):\n    '''\n        Discrete Logarithm for a curve that its parameter is smooth. \n        p: prime number \n        a, b: parameters of the curve\n        G: generator point\n        B: Bob's public key\n        A: Alice's public key\n    '''\n    E = EllipticCurve(GF(p), [a, b])\n    G = E(G)\n    B = E(B)\n    A = E(A)\n    b = G.discrete_log(B)\n    sharedSecret = (A*b).xy()[0]\n    return sharedSecret\n\np = 310717010502520989590157367261876774703\na = 2 \nb = 3\nG = [179210853392303317793440285562762725654, 105268671499942631758568591033409611165]\nB = [272640099140026426377756188075937988094, 51062462309521034358726608268084433317]\nA = [280810182131414898730378982766101210916, 291506490768054478159835604632710368904]\nprint(discreteLogarithm(p, a, b, G, B, A))\n\n\n171172176587165701252669133307091694084\n\n\nThere are several other methods for solving DLP in EC, but requires some specific properties of curve."
  },
  {
    "objectID": "HashFunctions.html",
    "href": "HashFunctions.html",
    "title": "20¬† Hash functions",
    "section": "",
    "text": "This chapter will give you an introduction to Hash functions, where and why apply them, and also a fun vulnerability: Hash Length Extension."
  },
  {
    "objectID": "HashFunctions.html#hash-function",
    "href": "HashFunctions.html#hash-function",
    "title": "20¬† Hash functions",
    "section": "20.1 Hash function",
    "text": "20.1 Hash function\nIn general, you can think the hash function as taking an arbitrary long data, and then ‚Äòcompress‚Äô it into a much smaller (and fixed size) string. It appears in many data structures, string recognition and many others in computer science.\nWith Cryptographic Hash Function, the function should be one-way: impossible to invert. Comparing with public key cryptography, this is a little bit different, as PKC processes could be invertible if some secrets is known. Here is an example of SHA1:\n\nCryptographic hash functions are used to validate messages, generate digital signatures, and store passwords securely in databases.\nHash functions are particularly helpful in asymmetric cryptography for compressing arbitrary length communications to a value with a smaller bit-length than the modulus when signing messages using RSA or protocols such as (EC)DSA or Elgamal.\nNormally, the cryptographic hash functions must be resistant to this three forms of attacks:\n\nPre-image attack: Given \\(x = hash(m)\\), it must be practically impossible to find \\(hash(m_0) = x\\). (This can be interpreted as one-way function).\nSecond pre-image attack: given \\(m_1, hash(m_1)\\), it must be impossible find \\(m_2\\) that \\(hash(m_1) = hash(m_2)\\).\nCollision: It must be practically impossible to find any pair of messages \\(m_1, m_2\\) that \\(hash(m_1) = hash(m_2)\\). The main difference of collision and second pre-image is that, collision do not require a known \\(m_1\\), but searching for a pair.\n\nOne remarkable think is: if a pre-image attack is known, then, it could lead to consequences as second pre-image attack and collision; but having a collision is not necessarily lead to other attacks.\nIn Python, hashlib works pretty well as a hash generator.\nimport hashlib\nh = hashlib.new('sha256')\nh.update(b\"Nobody inspects the spammish repetition\")\nh.hexdigest()\n\n\n'031edd7d41651593c5fe5c006fa5752b37fddff7bc4e843aa6af0c950f4b9406'\n\n\nYou can look more deeply in the hashlib documentation."
  },
  {
    "objectID": "HashFunctions.html#merkledamg√•rd-construction",
    "href": "HashFunctions.html#merkledamg√•rd-construction",
    "title": "20¬† Hash functions",
    "section": "20.2 Merkle‚ÄìDamg√•rd construction",
    "text": "20.2 Merkle‚ÄìDamg√•rd construction\nMerkle‚ÄìDamg√•rd construction is a proven way to build a good hash function.\n\nWe can talk pretty much about this Construction, but I will write here several key points in it:\n\nIt is proven that, if the block \\(f\\) is cryptographically secured, then the whole MD construction is secured.\nThe padding is a must-have in cryptographic hash function. And it also needs to be done in a good way.\n\nFor example, if we pad the message with only \\x00 if it does not fit the block of MD construction, then this two message:\nm1 = 'aaaaaaaaaaa'\naaa|aaa|aaa|aa0|\n              |padding\nm2 = 'aaaaaaaaaaa0'\naaa|aaa|aaa|aa0|\nwill have the same hash results. Normally, regardless of the size of message fits the required length for each block or not, the hash function will always pad it with some values.\n\nSad news many algorithm built on Merkle‚ÄìDamg√•rd is not cryptographically safe anymore, one big example is MD5.\n\nComputing the hash value of this two value raises the same hash:\na = 0xd131dd02c5e6eec4693d9a0698aff95c2fcab58712467eab4004583eb8fb7f8955ad340609f4b30283e488832571415a085125e8f7cdc99fd91dbdf280373c5bd8823e3156348f5bae6dacd436c919c6dd53e2b487da03fd02396306d248cda0e99f33420f577ee8ce54b67080a80d1ec69821bcb6a8839396f9652b6ff72a70\na_faker = 0xd131dd02c5e6eec4693d9a0698aff95c2fcab50712467eab4004583eb8fb7f8955ad340609f4b30283e4888325f1415a085125e8f7cdc99fd91dbd7280373c5bd8823e3156348f5bae6dacd436c919c6dd53e23487da03fd02396306d248cda0e99f33420f577ee8ce54b67080280d1ec69821bcb6a8839396f965ab6ff72a70\nimport hashlib\nhashMachine = MD5.new(a)\nprint(hashMachine.hexdigest())\nhashMachine = MD5.new(a_faker)\nprint(hashMachine.hexdigest())\n\n\n008ee33a9d58b51cfeb425b0959121c9\n008ee33a9d58b51cfeb425b0959121c9\n\n\nA very cool properties that hashes based on Merkle‚ÄìDamg√•rd construction is that, if a collision is found, if we append same bytes into the collision, it will continue to become a collision (You may can explain it by looking at MD construction)."
  },
  {
    "objectID": "HashFunctions.html#hash-length-extension",
    "href": "HashFunctions.html#hash-length-extension",
    "title": "20¬† Hash functions",
    "section": "20.3 Hash length extension",
    "text": "20.3 Hash length extension\nWith Merkle-Damgard construction-based hash, a very cool attack called Hash length extension.\nLooking back into the MD construction, the hash resulted after a process is the hashes of the message \\(m\\) and its padding \\(p\\), let‚Äôs name it \\(m || p\\).\nIf an adversary have the \\(hash(m || p)\\), and knowing length of \\(m\\), he could compute a valid hash of \\(m || p || z\\), with \\(z\\) is his invalid data.\nWhen the hash function needs to find \\(hash(m || p || z)\\), with \\(m || p\\) fits the block size (\\(len(m || p) = kn\\)), the next state will have IV as \\(hash(m || p)\\)!. For knowing this IV states, we can compute the continuous block. If attacker needs to forge a hash of \\(m || p || z || p'\\), for \\(p'\\) is the padding for \\(z\\), he would use IV as \\(hash(m || p)\\).\nAn example on Wikipedia:\nOriginal Data: count=10&lat=37.351&user_id=1&long=-119.827&waffle=eggo\nOriginal Signature: 6d5f807e23db210bc254a28be2d6759a0f5f5d99\nIf the hacker needs to craft this message:\nDesired New Data: count=10&lat=37.351&user_id=1&long=-119.827&waffle=eggo&waffle=liege\nAs we have known the signature of previous data, we can compute the hash value of the desired data, with IV = hash of original."
  },
  {
    "objectID": "FinalWords.html",
    "href": "FinalWords.html",
    "title": "Final Word",
    "section": "",
    "text": "Hi! That‚Äôs all of our journey (just for temporary).\nThank you for reading until this final page. Along the book, I would have several mistakes. Therefore, I would really appreciate your recommendations, fixes, etc. via connecting me at @h114mx001!\nFor the reference of the books, please look at the chapters: Guide on Mathematics & Crypto sources. I have put it all in here!\nThank you once time more! Goodbye and good luck during your infosec and crypto path!"
  },
  {
    "objectID": "GuideOnSource.html#sources",
    "href": "GuideOnSource.html#sources",
    "title": "2¬† Guide on Mathematics sources",
    "section": "2.2 Sources:",
    "text": "2.2 Sources:\nHere is some books that I am reading during my crypto path, and also websites that I practice crypto:\n\n2.2.1 Course\nThe only course, that I would recommend now is the Cryptography I course from professor Dan Boneh, Stanford University. This course would help you have a good background in both Mathematics and Theory of Crypto, also programming exercises included too. Also, you can have a certificate xD.\n\n\n2.2.2 Books\nCrypto-dedicated:\n\nAn Introduction To Mathematical Cryptography\nMathematics for Public Key Cryptography\n\nMaths:\n\nAbstract Algebra: Theory and Applications\n\nGeneral InfoSec:\n\nHandbook for CTF-ers - Highly recommend if you are new to infosec.\n\n\n\n2.2.3 Practice sites\n\nCryptoHack: A good site for both beginner and gurus, and a really practical & close to CTFs\nCryptoPals: Learn cryptography by programming and understanding the concepts from the scratch (also good if you want to learn a new programming language).\n\n(Will be update soon if I remember more =)))\nThat‚Äôs all! Let‚Äôs go!!!!!!!!!!!!!!"
  }
]